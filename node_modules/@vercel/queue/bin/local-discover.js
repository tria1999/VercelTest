#!/usr/bin/env node

/**
 * Standalone CLI script to discover queue handlers in development mode
 * This script is self-contained and doesn't import from the main package
 */

const fs = require("fs");
const path = require("path");

function showHelp() {
  console.log(`
@vercel/queue local-init - Initialize queue handlers in local development

USAGE:
  npx vercel-queue-local-init [options]

OPTIONS:
  --port <number>        Port number for Next.js dev server (default: 3000)
  --config <path>        Path to vercel.json file (default: ./vercel.json)
  --help, -h             Show this help message

EXAMPLES:
  npx vercel-queue-local-init
  npx vercel-queue-local-init --port 3001
  npx vercel-queue-local-init --config ./my-vercel.json
`);
}

/**
 * Read vercel.json and extract function endpoints with queue triggers
 */
function readVercelConfig(configPath = "./vercel.json") {
  try {
    const fullPath = path.resolve(configPath);
    const configContent = fs.readFileSync(fullPath, "utf-8");
    const config = JSON.parse(configContent);

    const routes = [];

    // Extract routes from functions with queue triggers
    if (config.functions) {
      for (const [functionPath, functionConfig] of Object.entries(
        config.functions,
      )) {
        if (
          functionConfig &&
          typeof functionConfig === "object" &&
          "experimentalTriggers" in functionConfig
        ) {
          const triggers = functionConfig.experimentalTriggers;
          if (Array.isArray(triggers)) {
            // Check if any trigger is a queue trigger
            const hasQueueTrigger = triggers.some(
              (trigger) =>
                trigger &&
                typeof trigger === "object" &&
                trigger.type === "queue/v1beta",
            );

            if (hasQueueTrigger) {
              // Convert file path to API route
              // Examples:
              // app/api/vm/queue/route.ts -> /api/vm/queue
              // app/(dashboard)/api/queue/route.ts -> /api/queue
              // app/(auth)/login/route.ts -> /login
              // src/app/api/queue/route.ts -> /api/queue
              // src/app/(admin)/settings/route.ts -> /settings
              // pages/api/queue.ts -> /api/queue
              // src/pages/api/queue.ts -> /api/queue
              // app/queue/route.ts -> /queue
              // src/app/webhooks/route.ts -> /webhooks
              let apiPath = functionPath;

              // Handle src/ prefix
              if (apiPath.startsWith("src/")) {
                apiPath = apiPath.replace("src/", "");
              }

              // Convert Next.js file paths to HTTP routes
              if (apiPath.startsWith("app/")) {
                // App Router: app/api/queue/route.ts -> /api/queue
                // App Router: app/queue/route.ts -> /queue
                apiPath = apiPath.replace("app/", "/");
              } else if (apiPath.startsWith("pages/api/")) {
                // Pages Router: pages/api/queue.ts -> /api/queue
                apiPath = apiPath.replace("pages/api/", "/api/");
              } else if (apiPath.startsWith("pages/")) {
                // Pages Router: pages/queue.ts -> /queue
                apiPath = apiPath.replace("pages/", "/");
              } else {
                // Fallback: assume it's a root-level route
                apiPath = "/" + apiPath;
              }

              // Remove Next.js route groups (folders wrapped in parentheses)
              // Route groups like (dashboard), (auth), (admin) are used for organization
              // but don't affect the URL structure
              apiPath = apiPath.replace(/\/\([^)]+\)/g, "");

              // Remove file extensions and Next.js-specific suffixes
              apiPath = apiPath.replace(
                /\/(route|index)\.(ts|js|tsx|jsx)$/,
                "",
              );
              apiPath = apiPath.replace(/\.(ts|js|tsx|jsx)$/, "");

              routes.push(apiPath);
            }
          }
        }
      }
    }

    return routes;
  } catch (error) {
    // vercel.json might not exist or be malformed
    return [];
  }
}

/**
 * Make OPTIONS requests to trigger Next.js lazy loading
 */
async function discoverQueueHandlers(options = {}) {
  const baseUrl = options.baseUrl || "http://localhost:3000";
  const configPath = options.configPath || "./vercel.json";

  let routes = options.routes || [];

  // Auto-discover from vercel.json
  if (routes.length === 0) {
    const configRoutes = readVercelConfig(configPath);
    if (configRoutes.length > 0) {
      routes = configRoutes;
      console.log(
        `[Dev Mode] Found ${configRoutes.length} queue endpoints in vercel.json`,
      );
    } else {
      console.error("[Dev Mode] No queue endpoints found in vercel.json");
      process.exit(1);
    }
  }

  console.log(
    "[Dev Mode] Making OPTIONS requests to trigger module loading...",
  );

  for (const route of routes) {
    try {
      // Make an OPTIONS request to trigger module loading without processing
      const response = await fetch(`${baseUrl}${route}`, {
        method: "OPTIONS",
        // Add a header to identify this as a discovery request
        headers: { "x-queue-discovery": "true" },
      });

      // Any response means the route exists and module was loaded
      console.log(`[Dev Mode] ✓ ${route} (${response.status})`);
    } catch (error) {
      // Ignore errors - route might not exist or server not running
      console.log(`[Dev Mode] ✗ ${route} (server may not be running)`);
    }
  }

  console.log("[Dev Mode] Module loading complete.");
}

async function main() {
  const args = process.argv.slice(2);
  const options = {};

  // Parse simple command line arguments
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === "--help" || arg === "-h") {
      showHelp();
      return;
    } else if (arg === "--port" && args[i + 1]) {
      options.baseUrl = `http://localhost:${args[i + 1]}`;
      i++;
    } else if (arg === "--config" && args[i + 1]) {
      options.configPath = args[i + 1];
      i++;
    }
  }

  try {
    await discoverQueueHandlers(options);
  } catch (error) {
    console.error("Failed to discover queue handlers:", error.message);
    process.exit(1);
  }
}

main();
