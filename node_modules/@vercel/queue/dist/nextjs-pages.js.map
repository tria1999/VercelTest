{"version":3,"sources":["../src/nextjs-pages.ts","../src/client.ts","../src/oidc.ts","../src/types.ts","../src/transports.ts","../src/dev.ts","../src/consumer-group.ts","../src/topic.ts","../src/callback.ts"],"sourcesContent":["import { handleCallback as handleCallbackWeb } from \"./callback\";\nimport type { MessageHandler } from \"./types\";\n\ntype CallbackHandlers = {\n  [topicName: string]: { [consumerGroup: string]: MessageHandler };\n};\n\ninterface NextApiRequest {\n  method?: string;\n  url?: string;\n  headers: Record<string, string | string[] | undefined>;\n  body?: any;\n  on(event: \"data\", listener: (chunk: Buffer) => void): void;\n  on(event: \"end\", listener: () => void): void;\n  on(event: \"error\", listener: (err: Error) => void): void;\n}\n\ninterface NextApiResponse {\n  status(statusCode: number): NextApiResponse;\n  setHeader(name: string, value: string): void;\n  json(data: any): void;\n  send(data: any): void;\n  end(): void;\n}\n\nfunction getHeader(\n  headers: Record<string, string | string[] | undefined>,\n  name: string,\n): string | undefined {\n  const value = headers[name];\n  return Array.isArray(value) ? value[0] : value;\n}\n\nfunction readBody(req: NextApiRequest): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const chunks: Buffer[] = [];\n    req.on(\"data\", (chunk) => chunks.push(chunk));\n    req.on(\"end\", () => resolve(Buffer.concat(chunks).toString(\"utf-8\")));\n    req.on(\"error\", reject);\n  });\n}\n\nasync function getBody(req: NextApiRequest): Promise<string> {\n  if (req.body === undefined) {\n    return readBody(req);\n  }\n  if (typeof req.body === \"string\") {\n    return req.body;\n  }\n  return JSON.stringify(req.body);\n}\n\nasync function createRequestFromNextApi(req: NextApiRequest): Promise<Request> {\n  const protocol = getHeader(req.headers, \"x-forwarded-proto\") ?? \"https\";\n  const host = getHeader(req.headers, \"host\");\n  if (!host) {\n    throw new Error(\"Missing host header\");\n  }\n\n  const url = `${protocol}://${host}${req.url}`;\n\n  const headers = new Headers();\n  for (const [key, value] of Object.entries(req.headers)) {\n    if (value) {\n      if (Array.isArray(value)) {\n        value.forEach((v) => headers.append(key, v));\n      } else {\n        headers.set(key, value);\n      }\n    }\n  }\n\n  const body = await getBody(req);\n\n  return new Request(url, {\n    method: req.method || \"POST\",\n    headers,\n    body,\n  });\n}\n\nasync function sendResponseToNextApi(\n  response: Response,\n  res: NextApiResponse,\n): Promise<void> {\n  res.status(response.status);\n\n  response.headers.forEach((value, key) => {\n    res.setHeader(key, value);\n  });\n\n  const contentType = response.headers.get(\"content-type\");\n  if (contentType?.includes(\"application/json\")) {\n    const data = await response.json();\n    res.json(data);\n  } else {\n    const text = await response.text();\n    res.send(text);\n  }\n}\n\n/**\n * Queue callback handler for Next.js Pages Router\n *\n * Automatically extracts queue information from CloudEvent format\n * and routes to the appropriate handler based on topic and consumer group.\n *\n * @param handlers Object with topic-specific handlers organized by consumer groups\n * @returns A Next.js Pages Router handler function\n *\n * @example\n * ```typescript\n * // pages/api/queue.ts\n * import { handleCallback } from \"@vercel/queue/nextjs/pages\";\n *\n * export default handleCallback({\n *   \"image-processing\": {\n *     \"compress\": (message, metadata) => console.log(\"Compressing image\", message),\n *     \"resize\": (message, metadata) => console.log(\"Resizing image\", message),\n *   }\n * });\n * ```\n */\nexport function handleCallback(\n  handlers: CallbackHandlers,\n): (req: NextApiRequest, res: NextApiResponse) => Promise<void> {\n  const webHandler = handleCallbackWeb(handlers);\n\n  return async (req: NextApiRequest, res: NextApiResponse) => {\n    // Pages Router receives all HTTP methods - only process POST\n    if (req.method !== \"POST\") {\n      res.status(200).end();\n      return;\n    }\n\n    try {\n      const request = await createRequestFromNextApi(req);\n      const response = await webHandler(request);\n      await sendResponseToNextApi(response, res);\n    } catch (error) {\n      console.error(\"Pages Router adapter error:\", error);\n      res.status(500).json({ error: \"Internal server error\" });\n    }\n  };\n}\n","import { parseMultipartStream } from \"mixpart\";\nimport { getVercelOidcToken } from \"./oidc\";\nimport type {\n  ChangeVisibilityOptions,\n  ChangeVisibilityResponse,\n  DeleteMessageOptions,\n  DeleteMessageResponse,\n  Message,\n  QueueClientOptions,\n  ReceiveMessageByIdOptions,\n  ReceiveMessageByIdResponse,\n  ReceiveMessagesOptions,\n  SendMessageOptions,\n  SendMessageResponse,\n  Transport,\n} from \"./types\";\nimport {\n  BadRequestError,\n  ForbiddenError,\n  InternalServerError,\n  InvalidLimitError,\n  MessageCorruptedError,\n  MessageLockedError,\n  MessageNotAvailableError,\n  MessageNotFoundError,\n  QueueEmptyError,\n  UnauthorizedError,\n} from \"./types\";\n\n/**\n * Check if debug logging is enabled via environment variable\n */\nfunction isDebugEnabled(): boolean {\n  return (\n    process.env.VERCEL_QUEUE_DEBUG === \"1\" ||\n    process.env.VERCEL_QUEUE_DEBUG === \"true\"\n  );\n}\n\n/**\n * Helper function to consume a ReadableStream to completion\n * This is necessary when we need to drain a stream to let the multipart parser proceed\n */\nasync function consumeStream(\n  stream: ReadableStream<Uint8Array>,\n): Promise<void> {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { done } = await reader.read();\n      if (done) break;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n/**\n * Helper function to parse the Retry-After header value\n */\nfunction parseRetryAfter(headers: Headers): number | undefined {\n  const retryAfterHeader = headers.get(\"Retry-After\");\n  if (retryAfterHeader) {\n    const parsed = parseInt(retryAfterHeader, 10);\n    return Number.isNaN(parsed) ? undefined : parsed;\n  }\n  return undefined;\n}\n\n/**\n * Helper function to throw common HTTP errors (400, 401, 403, 500+)\n * Call this after checking for any method-specific error codes (404, 409, 423)\n */\nfunction throwCommonHttpError(\n  status: number,\n  statusText: string,\n  errorText: string,\n  operation: string,\n  badRequestDefault: string = \"Invalid parameters\",\n): never {\n  if (status === 400) {\n    throw new BadRequestError(errorText || badRequestDefault);\n  }\n  if (status === 401) {\n    throw new UnauthorizedError(errorText || undefined);\n  }\n  if (status === 403) {\n    throw new ForbiddenError(errorText || undefined);\n  }\n  if (status >= 500) {\n    throw new InternalServerError(\n      errorText || `Server error: ${status} ${statusText}`,\n    );\n  }\n  throw new Error(`Failed to ${operation}: ${status} ${statusText}`);\n}\n\n/**\n * Helper function to parse queue headers into a partial message object\n * Handles both multipart message headers and HTTP response headers\n */\nfunction parseQueueHeaders(\n  headers: Headers,\n): Omit<Message<unknown>, \"payload\"> | null {\n  const messageId = headers.get(\"Vqs-Message-Id\");\n  const deliveryCountStr = headers.get(\"Vqs-Delivery-Count\") || \"0\";\n  const timestamp = headers.get(\"Vqs-Timestamp\");\n  const contentType = headers.get(\"Content-Type\") || \"application/octet-stream\";\n  const ticket = headers.get(\"Vqs-Ticket\");\n\n  if (!messageId || !timestamp || !ticket) {\n    return null;\n  }\n\n  const deliveryCount = parseInt(deliveryCountStr, 10);\n  if (Number.isNaN(deliveryCount)) {\n    return null;\n  }\n\n  return {\n    messageId,\n    deliveryCount,\n    createdAt: new Date(timestamp),\n    contentType,\n    ticket,\n  };\n}\n\n/**\n * Internal client for interacting with the Vercel Queue Service API\n * Use Client for the public-facing wrapper with send/handleCallback methods\n */\nexport class QueueClient {\n  private baseUrl: string;\n  private basePath: string;\n  private customHeaders: Record<string, string>;\n  private providedToken?: string;\n\n  /**\n   * Create a new Vercel Queue Service client\n   * @param options QueueClient configuration options\n   */\n  constructor(options: QueueClientOptions = {}) {\n    this.baseUrl =\n      options.baseUrl ||\n      process.env.VERCEL_QUEUE_BASE_URL ||\n      \"https://vercel-queue.com\";\n    this.basePath =\n      options.basePath ||\n      process.env.VERCEL_QUEUE_BASE_PATH ||\n      \"/api/v2/messages\";\n    this.customHeaders = options.headers || {};\n    this.providedToken = options.token;\n  }\n\n  private async getToken(): Promise<string> {\n    // Use provided token if available\n    if (this.providedToken) {\n      return this.providedToken;\n    }\n\n    const token = await getVercelOidcToken();\n    if (!token) {\n      throw new Error(\n        \"Failed to get OIDC token from Vercel Functions. \" +\n          \"Make sure you are running in a Vercel Function environment, or provide a token explicitly.\\n\\n\" +\n          \"To set up your environment:\\n\" +\n          \"1. Link your project: 'vercel link'\\n\" +\n          \"2. Pull environment variables: 'vercel env pull'\\n\" +\n          \"3. Run with environment: 'dotenv -e .env.local -- your-command'\",\n      );\n    }\n    return token;\n  }\n\n  /**\n   * Internal fetch wrapper that automatically handles debug logging\n   * when VERCEL_QUEUE_DEBUG is enabled\n   */\n  private async fetch(\n    url: string,\n    init: RequestInit & { headers: Headers },\n  ): Promise<Response> {\n    const method = init.method || \"GET\";\n\n    // Log request if debug is enabled\n    if (isDebugEnabled()) {\n      const logData: Record<string, unknown> = {\n        method,\n        url,\n        headers: init.headers,\n      };\n\n      // Log body size/type if present (don't log actual body content for privacy)\n      const body = init.body;\n      if (body !== undefined && body !== null) {\n        if (body instanceof ArrayBuffer) {\n          logData.bodySize = body.byteLength;\n        } else if (body instanceof Uint8Array) {\n          logData.bodySize = body.byteLength;\n        } else if (typeof body === \"string\") {\n          logData.bodySize = body.length;\n        } else {\n          logData.bodyType = typeof body;\n        }\n      }\n\n      console.debug(\"[VQS Debug] Request:\", JSON.stringify(logData, null, 2));\n    }\n\n    const response = await fetch(url, init);\n\n    // Log response if debug is enabled\n    if (isDebugEnabled()) {\n      const logData: Record<string, unknown> = {\n        method,\n        url,\n        status: response.status,\n        statusText: response.statusText,\n        headers: response.headers,\n      };\n\n      console.debug(\"[VQS Debug] Response:\", JSON.stringify(logData, null, 2));\n    }\n\n    return response;\n  }\n\n  /**\n   * Send a message to a queue\n   * @param options Send message options\n   * @param transport Serializer/deserializer for the payload\n   * @returns Promise with the message ID\n   * @throws {BadRequestError} When request parameters are invalid\n   * @throws {UnauthorizedError} When authentication fails\n   * @throws {ForbiddenError} When access is denied (environment mismatch)\n   * @throws {InternalServerError} When server encounters an error\n   */\n  async sendMessage<T = unknown>(\n    options: SendMessageOptions<T>,\n    transport: Transport<T>,\n  ): Promise<SendMessageResponse> {\n    const { queueName, payload, idempotencyKey, retentionSeconds } = options;\n\n    const headers = new Headers({\n      Authorization: `Bearer ${await this.getToken()}`,\n      \"Vqs-Queue-Name\": queueName,\n      \"Content-Type\": transport.contentType,\n      ...this.customHeaders,\n    });\n\n    const deploymentId =\n      options.deploymentId || process.env.VERCEL_DEPLOYMENT_ID;\n    if (deploymentId) {\n      headers.set(\"Vqs-Deployment-Id\", deploymentId);\n    }\n\n    if (idempotencyKey) {\n      headers.set(\"Vqs-Idempotency-Key\", idempotencyKey);\n    }\n\n    if (retentionSeconds !== undefined) {\n      headers.set(\"Vqs-Retention-Seconds\", retentionSeconds.toString());\n    }\n\n    // Serialize the payload using the provided transport\n    const body = transport.serialize(payload);\n\n    const response = await this.fetch(`${this.baseUrl}${this.basePath}`, {\n      method: \"POST\",\n      body,\n      headers,\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      // Method-specific: 409 for duplicate idempotency key\n      if (response.status === 409) {\n        throw new Error(\"Duplicate idempotency key detected\");\n      }\n      throwCommonHttpError(\n        response.status,\n        response.statusText,\n        errorText,\n        \"send message\",\n      );\n    }\n\n    const responseData = (await response.json()) as SendMessageResponse;\n\n    return responseData;\n  }\n\n  /**\n   * Receive messages from a queue\n   * @param options Receive messages options\n   * @param transport Serializer/deserializer for the payload\n   * @returns AsyncGenerator that yields messages as they arrive\n   * @throws {InvalidLimitError} When limit parameter is not between 1 and 10\n   * @throws {QueueEmptyError} When no messages are available (204)\n   * @throws {MessageLockedError} When messages are temporarily locked (423)\n   * @throws {BadRequestError} When request parameters are invalid\n   * @throws {UnauthorizedError} When authentication fails\n   * @throws {ForbiddenError} When access is denied (environment mismatch)\n   * @throws {InternalServerError} When server encounters an error\n   */\n  async *receiveMessages<T = unknown>(\n    options: ReceiveMessagesOptions<T>,\n    transport: Transport<T>,\n  ): AsyncGenerator<Message<T>, void, unknown> {\n    const { queueName, consumerGroup, visibilityTimeoutSeconds, limit } =\n      options;\n\n    // Validate limit parameter\n    if (limit !== undefined && (limit < 1 || limit > 10)) {\n      throw new InvalidLimitError(limit);\n    }\n\n    const headers = new Headers({\n      Authorization: `Bearer ${await this.getToken()}`,\n      \"Vqs-Queue-Name\": queueName,\n      \"Vqs-Consumer-Group\": consumerGroup,\n      Accept: \"multipart/mixed\",\n      ...this.customHeaders,\n    });\n\n    if (visibilityTimeoutSeconds !== undefined) {\n      headers.set(\n        \"Vqs-Visibility-Timeout\",\n        visibilityTimeoutSeconds.toString(),\n      );\n    }\n\n    if (limit !== undefined) {\n      headers.set(\"Vqs-Limit\", limit.toString());\n    }\n\n    const response = await this.fetch(`${this.baseUrl}${this.basePath}`, {\n      method: \"GET\",\n      headers,\n    });\n\n    // Check for 204 No Content - queue is empty\n    if (response.status === 204) {\n      throw new QueueEmptyError(queueName, consumerGroup);\n    }\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      // Method-specific: 423 for message locked\n      if (response.status === 423) {\n        throw new MessageLockedError(\n          \"next message\",\n          parseRetryAfter(response.headers),\n        );\n      }\n      throwCommonHttpError(\n        response.status,\n        response.statusText,\n        errorText,\n        \"receive messages\",\n      );\n    }\n\n    // Stream messages as they arrive from the multipart parser\n    // Each message's payload stream must be consumed immediately for the parser to proceed\n    for await (const multipartMessage of parseMultipartStream(response)) {\n      try {\n        // Parse VQS headers using the helper function\n        const parsedHeaders = parseQueueHeaders(multipartMessage.headers);\n\n        if (!parsedHeaders) {\n          console.warn(\"Missing required queue headers in multipart part\");\n          // Still need to consume the payload stream to let the parser proceed\n          await consumeStream(multipartMessage.payload);\n          continue;\n        }\n\n        // Deserialize using the provided transport (must consume the stream)\n        const deserializedPayload = await transport.deserialize(\n          multipartMessage.payload,\n        );\n\n        const message: Message<T> = {\n          ...parsedHeaders,\n          payload: deserializedPayload,\n        };\n\n        yield message;\n      } catch (error) {\n        console.warn(\"Failed to process multipart message:\", error);\n        // If deserialization failed, we still need to consume the payload stream\n        // to let the multipart parser proceed to the next message\n        await consumeStream(multipartMessage.payload);\n      }\n    }\n  }\n\n  /**\n   * Receive a specific message by its ID from a queue\n   * @param options Receive message by ID options\n   * @param transport Serializer/deserializer for the payload\n   * @returns Promise with the message or null if not found/available\n   * @throws {MessageNotFoundError} When the message doesn't exist (404)\n   * @throws {MessageLockedError} When the message is temporarily locked (423)\n   * @throws {MessageNotAvailableError} When message exists but isn't available (409)\n   * @throws {MessageCorruptedError} When message data is corrupted\n   * @throws {BadRequestError} When request parameters are invalid\n   * @throws {UnauthorizedError} When authentication fails\n   * @throws {ForbiddenError} When access is denied (environment mismatch)\n   * @throws {InternalServerError} When server encounters an error\n   */\n  async receiveMessageById<T = unknown>(\n    options: ReceiveMessageByIdOptions<T> & { skipPayload: true },\n    transport?: Transport<T>,\n  ): Promise<ReceiveMessageByIdResponse<T, true>>;\n  async receiveMessageById<T = unknown>(\n    options: ReceiveMessageByIdOptions<T> & { skipPayload?: false | undefined },\n    transport: Transport<T>,\n  ): Promise<ReceiveMessageByIdResponse<T, false>>;\n  async receiveMessageById<T = unknown>(\n    options: ReceiveMessageByIdOptions<T>,\n    transport?: Transport<T>,\n  ): Promise<ReceiveMessageByIdResponse<T, boolean>> {\n    const {\n      queueName,\n      consumerGroup,\n      messageId,\n      visibilityTimeoutSeconds,\n      skipPayload,\n    } = options;\n\n    const headers = new Headers({\n      Authorization: `Bearer ${await this.getToken()}`,\n      \"Vqs-Queue-Name\": queueName,\n      \"Vqs-Consumer-Group\": consumerGroup,\n      Accept: \"multipart/mixed\",\n      ...this.customHeaders,\n    });\n\n    if (visibilityTimeoutSeconds !== undefined) {\n      headers.set(\n        \"Vqs-Visibility-Timeout\",\n        visibilityTimeoutSeconds.toString(),\n      );\n    }\n\n    if (skipPayload) {\n      headers.set(\"Vqs-Skip-Payload\", \"1\");\n    }\n\n    const response = await this.fetch(\n      `${this.baseUrl}${this.basePath}/${encodeURIComponent(messageId)}`,\n      {\n        method: \"GET\",\n        headers,\n      },\n    );\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      // Method-specific error handling\n      if (response.status === 404) {\n        throw new MessageNotFoundError(messageId);\n      }\n      if (response.status === 409) {\n        throw new MessageNotAvailableError(messageId);\n      }\n      if (response.status === 423) {\n        throw new MessageLockedError(\n          messageId,\n          parseRetryAfter(response.headers),\n        );\n      }\n      throwCommonHttpError(\n        response.status,\n        response.statusText,\n        errorText,\n        \"receive message by ID\",\n      );\n    }\n\n    // Handle skipPayload case with 204 response\n    if (skipPayload && response.status === 204) {\n      const parsedHeaders = parseQueueHeaders(response.headers);\n\n      if (!parsedHeaders) {\n        throw new MessageCorruptedError(\n          messageId,\n          \"Missing required queue headers in 204 response\",\n        );\n      }\n\n      const message: Message<void> = {\n        ...parsedHeaders,\n        payload: undefined as void,\n      };\n\n      return { message } as ReceiveMessageByIdResponse<T, boolean>;\n    }\n\n    // Handle regular multipart response\n    if (!transport) {\n      throw new Error(\"Transport is required when skipPayload is not true\");\n    }\n\n    // Parse multipart/mixed response using streaming parser\n    try {\n      for await (const multipartMessage of parseMultipartStream(response)) {\n        try {\n          // Parse queue headers using the helper function\n          const parsedHeaders = parseQueueHeaders(multipartMessage.headers);\n\n          if (!parsedHeaders) {\n            console.warn(\"Missing required queue headers in multipart part\");\n            // Still need to consume the payload stream to let the parser proceed\n            await consumeStream(multipartMessage.payload);\n            continue;\n          }\n\n          // Deserialize using the provided transport (must consume the stream)\n          const deserializedPayload = await transport.deserialize(\n            multipartMessage.payload,\n          );\n\n          const message: Message<T> = {\n            ...parsedHeaders,\n            payload: deserializedPayload,\n          };\n\n          return { message };\n        } catch (error) {\n          console.warn(\"Failed to deserialize message by ID:\", error);\n          // If deserialization failed, we still need to consume the payload stream\n          // to let the multipart parser proceed to the next message\n          await consumeStream(multipartMessage.payload);\n          throw new MessageCorruptedError(\n            messageId,\n            `Failed to deserialize payload: ${error}`,\n          );\n        }\n      }\n    } catch (error) {\n      if (error instanceof MessageCorruptedError) {\n        throw error; // Re-throw our own errors\n      }\n      throw new MessageCorruptedError(\n        messageId,\n        `Failed to parse multipart response: ${error}`,\n      );\n    }\n\n    // If we get here, no message was found in the multipart response\n    throw new MessageNotFoundError(messageId);\n  }\n\n  /**\n   * Delete a message (acknowledge processing)\n   * @param options Delete message options\n   * @returns Promise with delete status\n   * @throws {MessageNotFoundError} When the message doesn't exist (404)\n   * @throws {MessageNotAvailableError} When message can't be deleted (409)\n   * @throws {BadRequestError} When ticket is missing or invalid (400)\n   * @throws {UnauthorizedError} When authentication fails\n   * @throws {ForbiddenError} When access is denied (environment mismatch)\n   * @throws {InternalServerError} When server encounters an error\n   */\n  async deleteMessage(\n    options: DeleteMessageOptions,\n  ): Promise<DeleteMessageResponse> {\n    const { queueName, consumerGroup, messageId, ticket } = options;\n\n    const response = await this.fetch(\n      `${this.baseUrl}${this.basePath}/${encodeURIComponent(messageId)}`,\n      {\n        method: \"DELETE\",\n        headers: new Headers({\n          Authorization: `Bearer ${await this.getToken()}`,\n          \"Vqs-Queue-Name\": queueName,\n          \"Vqs-Consumer-Group\": consumerGroup,\n          \"Vqs-Ticket\": ticket,\n          ...this.customHeaders,\n        }),\n      },\n    );\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      // Method-specific error handling\n      if (response.status === 404) {\n        throw new MessageNotFoundError(messageId);\n      }\n      if (response.status === 409) {\n        throw new MessageNotAvailableError(\n          messageId,\n          errorText ||\n            \"Invalid ticket, message not in correct state, or already processed\",\n        );\n      }\n      throwCommonHttpError(\n        response.status,\n        response.statusText,\n        errorText,\n        \"delete message\",\n        \"Missing or invalid ticket\",\n      );\n    }\n\n    return { deleted: true };\n  }\n\n  /**\n   * Change the visibility timeout of a message\n   * @param options Change visibility options\n   * @returns Promise with update status\n   * @throws {MessageNotFoundError} When the message doesn't exist (404)\n   * @throws {MessageNotAvailableError} When message can't be updated (409)\n   * @throws {BadRequestError} When ticket is missing or visibility timeout invalid (400)\n   * @throws {UnauthorizedError} When authentication fails\n   * @throws {ForbiddenError} When access is denied (environment mismatch)\n   * @throws {InternalServerError} When server encounters an error\n   */\n  async changeVisibility(\n    options: ChangeVisibilityOptions,\n  ): Promise<ChangeVisibilityResponse> {\n    const {\n      queueName,\n      consumerGroup,\n      messageId,\n      ticket,\n      visibilityTimeoutSeconds,\n    } = options;\n\n    const response = await this.fetch(\n      `${this.baseUrl}${this.basePath}/${encodeURIComponent(messageId)}`,\n      {\n        method: \"PATCH\",\n        headers: new Headers({\n          Authorization: `Bearer ${await this.getToken()}`,\n          \"Vqs-Queue-Name\": queueName,\n          \"Vqs-Consumer-Group\": consumerGroup,\n          \"Vqs-Ticket\": ticket,\n          \"Vqs-Visibility-Timeout\": visibilityTimeoutSeconds.toString(),\n          ...this.customHeaders,\n        }),\n      },\n    );\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      // Method-specific error handling\n      if (response.status === 404) {\n        throw new MessageNotFoundError(messageId);\n      }\n      if (response.status === 409) {\n        throw new MessageNotAvailableError(\n          messageId,\n          errorText ||\n            \"Invalid ticket, message not in correct state, or already processed\",\n        );\n      }\n      throwCommonHttpError(\n        response.status,\n        response.statusText,\n        errorText,\n        \"change visibility\",\n        \"Missing ticket or invalid visibility timeout\",\n      );\n    }\n\n    return { updated: true };\n  }\n}\n","export { getVercelOidcToken } from \"@vercel/oidc\";\n","/**\n * Vercel Queue Service client types\n */\nimport type { Transport } from \"./transports\";\n\n// Re-export transport interface for convenience\nexport type { Transport };\n\nexport interface QueueClientOptions {\n  /**\n   * Base URL for the Vercel Queue Service API\n   * Can also be set via VERCEL_QUEUE_BASE_URL environment variable\n   * @default \"https://vercel-queue.com\"\n   */\n  baseUrl?: string;\n  /**\n   * Base path for API endpoints\n   * Can also be set via VERCEL_QUEUE_BASE_PATH environment variable\n   * @default \"/api/v2/messages\"\n   */\n  basePath?: string;\n  /**\n   * Authentication token for the Vercel Queue Service API\n   * If not provided, the client will attempt to get a token via OIDC\n   */\n  token?: string;\n  /**\n   * Custom headers to include in all requests\n   */\n  headers?: Record<string, string>;\n}\n\n/**\n * Shared options for publishing messages\n */\nexport interface PublishOptions {\n  /**\n   * Unique key to prevent duplicate message submissions\n   * @default random UUID\n   */\n  idempotencyKey?: string;\n  /**\n   * Message retention time in seconds\n   * @default 86400 (24 hours)\n   * @min 60\n   * @max 86400\n   */\n  retentionSeconds?: number;\n  /**\n   * Explicit deployment identifier to include in the `Vqs-Deployment-Id` header\n   * If provided, this takes precedence over any value from the environment\n   */\n  deploymentId?: string;\n}\n\nexport interface SendMessageOptions<T = unknown> extends PublishOptions {\n  /**\n   * The queue name to send the message to\n   */\n  queueName: string;\n  /**\n   * The message payload\n   */\n  payload: T;\n}\n\nexport interface SendMessageResponse {\n  /**\n   * The generated message ID\n   */\n  messageId: string;\n}\n\nexport interface Message<T = unknown> {\n  /**\n   * The message ID\n   */\n  messageId: string;\n  /**\n   * The deserialized message payload\n   * Note: If using streaming transports, ensure proper cleanup by calling transport.finalize(payload)\n   * when done processing, especially in error cases\n   */\n  payload: T;\n  /**\n   * Number of times this message has been delivered\n   */\n  deliveryCount: number;\n  /**\n   * When the message was created\n   */\n  createdAt: Date;\n  /**\n   * MIME type of the message content\n   */\n  contentType: string;\n  /**\n   * Unique ticket for this message delivery (required for delete/patch operations)\n   */\n  ticket: string;\n}\n\nexport interface ReceiveMessagesOptions<T = unknown> {\n  /**\n   * The queue name to receive messages from\n   */\n  queueName: string;\n  /**\n   * Consumer group name\n   */\n  consumerGroup: string;\n  /**\n   * Time in seconds that messages will be invisible to other consumers\n   * @default 900 (15 minutes)\n   */\n  visibilityTimeoutSeconds?: number;\n  /**\n   * Maximum number of messages to retrieve\n   * @default 10\n   * @max 10\n   */\n  limit?: number;\n}\n\nexport interface DeleteMessageOptions {\n  /**\n   * The queue name the message belongs to\n   */\n  queueName: string;\n  /**\n   * Consumer group name\n   */\n  consumerGroup: string;\n  /**\n   * The message ID to delete\n   */\n  messageId: string;\n  /**\n   * Ticket received from the message\n   */\n  ticket: string;\n}\n\nexport interface DeleteMessageResponse {\n  /**\n   * Whether the message was successfully deleted\n   */\n  deleted: boolean;\n}\n\nexport interface ChangeVisibilityOptions {\n  /**\n   * The queue name the message belongs to\n   */\n  queueName: string;\n  /**\n   * Consumer group name\n   */\n  consumerGroup: string;\n  /**\n   * The message ID to update\n   */\n  messageId: string;\n  /**\n   * Ticket received from the message\n   */\n  ticket: string;\n  /**\n   * New visibility timeout in seconds\n   */\n  visibilityTimeoutSeconds: number;\n}\n\nexport interface ChangeVisibilityResponse {\n  /**\n   * Whether the visibility was successfully updated\n   */\n  updated: boolean;\n}\n\n/**\n * Result indicating the message should be timed out for retry later\n */\nexport interface MessageTimeoutResult {\n  /**\n   * Time in seconds before the message becomes visible again\n   */\n  timeoutSeconds: number;\n}\n\n/**\n * Result returned by message handlers\n */\nexport type MessageHandlerResult = void | MessageTimeoutResult;\n\n/**\n * Message metadata provided to handlers\n */\nexport interface MessageMetadata {\n  messageId: string;\n  deliveryCount: number;\n  createdAt: Date;\n  topicName: string;\n  consumerGroup: string;\n}\n\n/**\n * Message handler function type\n */\nexport type MessageHandler<T = unknown> = (\n  message: T,\n  metadata: MessageMetadata,\n) => Promise<MessageHandlerResult> | MessageHandlerResult;\n\n/**\n * Options for creating a ConsumerGroup instance\n */\nexport interface ConsumerGroupOptions<T = unknown> {\n  /**\n   * Serializer/deserializer for the payload\n   * @default JsonTransport instance\n   */\n  transport?: Transport<T>;\n  /**\n   * Time in seconds that messages will be invisible to other consumers\n   * @default 30\n   */\n  visibilityTimeoutSeconds?: number;\n  /**\n   * How often to refresh the visibility timeout during processing (in seconds)\n   * @default 10\n   */\n  refreshInterval?: number;\n}\n\nexport interface ReceiveMessageByIdOptions<T = unknown> {\n  /**\n   * The queue name to receive the message from\n   */\n  queueName: string;\n  /**\n   * Consumer group name\n   */\n  consumerGroup: string;\n  /**\n   * The message ID to retrieve\n   */\n  messageId: string;\n  /**\n   * Time in seconds that the message will be invisible to other consumers\n   * @default 900 (15 minutes)\n   */\n  visibilityTimeoutSeconds?: number;\n  /**\n   * Skip payload content and only return message metadata\n   * When true, the server returns a 204 status with headers containing message metadata\n   * @default false\n   */\n  skipPayload?: boolean;\n}\n\n// Response type that always contains a message (errors are thrown for failures)\nexport interface ReceiveMessageByIdResponse<\n  T = unknown,\n  TSkipPayload extends boolean = false,\n> {\n  message: TSkipPayload extends true ? Message<void> : Message<T>;\n}\n\n/**\n * Error thrown when a message is not found (404)\n */\nexport class MessageNotFoundError extends Error {\n  constructor(messageId: string) {\n    super(`Message ${messageId} not found`);\n    this.name = \"MessageNotFoundError\";\n  }\n}\n\n/**\n * Error thrown when a message is not available for processing (409)\n * This can happen when the message is in the wrong state, already claimed, etc.\n */\nexport class MessageNotAvailableError extends Error {\n  constructor(messageId: string, reason?: string) {\n    super(\n      `Message ${messageId} not available for processing${reason ? `: ${reason}` : \"\"}`,\n    );\n    this.name = \"MessageNotAvailableError\";\n  }\n}\n\n/**\n * Error thrown when message data is corrupted or can't be parsed\n */\nexport class MessageCorruptedError extends Error {\n  constructor(messageId: string, reason: string) {\n    super(`Message ${messageId} is corrupted: ${reason}`);\n    this.name = \"MessageCorruptedError\";\n  }\n}\n\n/**\n * Error thrown when there are no messages available in the queue (204)\n */\nexport class QueueEmptyError extends Error {\n  constructor(queueName: string, consumerGroup: string) {\n    super(\n      `No messages available in queue \"${queueName}\" for consumer group \"${consumerGroup}\"`,\n    );\n    this.name = \"QueueEmptyError\";\n  }\n}\n\n/**\n * Error thrown when a message is temporarily locked (423)\n */\nexport class MessageLockedError extends Error {\n  public readonly retryAfter?: number;\n\n  constructor(messageId: string, retryAfter?: number) {\n    const retryMessage = retryAfter\n      ? ` Retry after ${retryAfter} seconds.`\n      : \" Try again later.\";\n    super(`Message ${messageId} is temporarily locked.${retryMessage}`);\n    this.name = \"MessageLockedError\";\n    this.retryAfter = retryAfter;\n  }\n}\n\n/**\n * Error thrown when authentication fails (401)\n */\nexport class UnauthorizedError extends Error {\n  constructor(message: string = \"Missing or invalid authentication token\") {\n    super(message);\n    this.name = \"UnauthorizedError\";\n  }\n}\n\n/**\n * Error thrown when access is forbidden (403)\n */\nexport class ForbiddenError extends Error {\n  constructor(\n    message: string = \"Queue environment doesn't match token environment\",\n  ) {\n    super(message);\n    this.name = \"ForbiddenError\";\n  }\n}\n\n/**\n * Error thrown for bad requests (400)\n */\nexport class BadRequestError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"BadRequestError\";\n  }\n}\n\n/**\n * Error thrown for internal server errors (500)\n */\nexport class InternalServerError extends Error {\n  constructor(message: string = \"Unexpected server error\") {\n    super(message);\n    this.name = \"InternalServerError\";\n  }\n}\n\n/**\n * Error thrown when batch limit parameter is invalid\n */\nexport class InvalidLimitError extends Error {\n  constructor(limit: number, min: number = 1, max: number = 10) {\n    super(`Invalid limit: ${limit}. Limit must be between ${min} and ${max}.`);\n    this.name = \"InvalidLimitError\";\n  }\n}\n","/**\n * Serializer/Deserializer interface for message payloads\n */\nexport interface Transport<T = unknown> {\n  /**\n   * Serialize a value to a buffer or stream for transmission\n   */\n  serialize(value: T): Buffer | ReadableStream<Uint8Array>;\n\n  /**\n   * Deserialize a readable stream back to the original value\n   */\n  deserialize(stream: ReadableStream<Uint8Array>): Promise<T>;\n\n  /**\n   * Optional cleanup method for deserialized payloads that may contain resources\n   * Should be called when the payload is no longer needed, especially in error cases\n   * @param payload The deserialized payload to clean up\n   */\n  finalize?(payload: T): Promise<void>;\n\n  /**\n   * MIME type for this serialization format\n   */\n  contentType: string;\n}\n\nasync function streamToBuffer(\n  stream: ReadableStream<Uint8Array>,\n): Promise<Buffer> {\n  let totalLength = 0;\n  const reader = stream.getReader();\n  const chunks: Uint8Array[] = [];\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n      chunks.push(value);\n      totalLength += value.length;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n\n  // Combine chunks into a single buffer\n  return Buffer.concat(chunks, totalLength);\n}\n\n/**\n * Built-in JSON serializer/deserializer\n * This implementation reads the entire stream into memory for JSON parsing\n */\nexport class JsonTransport<T = unknown> implements Transport<T> {\n  readonly contentType = \"application/json\";\n  readonly replacer?: Parameters<typeof JSON.parse>[1];\n  readonly reviver?: Parameters<typeof JSON.parse>[1];\n\n  constructor(\n    options: {\n      replacer?: Parameters<typeof JSON.parse>[1];\n      reviver?: Parameters<typeof JSON.parse>[1];\n    } = {},\n  ) {\n    this.replacer = options.replacer;\n    this.reviver = options.reviver;\n  }\n\n  serialize(value: T): Buffer {\n    return Buffer.from(JSON.stringify(value, this.replacer), \"utf8\");\n  }\n\n  async deserialize(stream: ReadableStream<Uint8Array>): Promise<T> {\n    // JSON requires reading the entire payload to parse\n    const buffer = await streamToBuffer(stream);\n    return JSON.parse(buffer.toString(\"utf8\"), this.reviver);\n  }\n}\n\n/**\n * Built-in Buffer serializer/deserializer (reads entire stream into a Buffer)\n */\nexport class BufferTransport implements Transport<Buffer> {\n  readonly contentType = \"application/octet-stream\";\n\n  serialize(value: Buffer): Buffer {\n    return value;\n  }\n\n  async deserialize(stream: ReadableStream<Uint8Array>): Promise<Buffer> {\n    // Buffer transport reads the entire stream into memory\n    return await streamToBuffer(stream);\n  }\n}\n\n/**\n * Stream serializer/deserializer (pass-through for streaming binary data)\n * This is ideal for large payloads that don't need to be buffered in memory\n *\n * IMPORTANT: When using StreamTransport, you must call finalize(payload) when done\n * processing the message to prevent resource leaks, especially in error cases.\n * ConsumerGroup handles this automatically, but direct Client usage requires manual cleanup.\n *\n * Example usage:\n * ```typescript\n * const transport = new StreamTransport();\n * try {\n *   for await (const message of client.receiveMessages(options, transport)) {\n *     // Process the stream...\n *     const reader = message.payload.getReader();\n *     // ... handle stream data\n *   }\n * } catch (error) {\n *   // Cleanup is handled automatically by ConsumerGroup\n *   // or manually: await transport.finalize(message.payload);\n * }\n */\nexport class StreamTransport implements Transport<ReadableStream<Uint8Array>> {\n  readonly contentType = \"application/octet-stream\";\n\n  serialize(value: ReadableStream<Uint8Array>): ReadableStream<Uint8Array> {\n    // Pass through the stream directly without buffering\n    return value;\n  }\n\n  async deserialize(\n    stream: ReadableStream<Uint8Array>,\n  ): Promise<ReadableStream<Uint8Array>> {\n    // Pass through the stream directly without buffering\n    return stream;\n  }\n\n  async finalize(payload: ReadableStream<Uint8Array>): Promise<void> {\n    // Consume any remaining stream data to prevent resource leaks\n    const reader = payload.getReader();\n    try {\n      while (true) {\n        const { done } = await reader.read();\n        if (done) break;\n      }\n    } finally {\n      reader.releaseLock();\n    }\n  }\n}\n","/**\n * Development mode utilities for local queue compatibility\n * This file contains helpers that enable local callback triggering in development mode\n *\n * Key behaviors:\n * - Exact topic matches: Latest handler wins for each topic:consumerGroup pair\n * - Wildcard patterns: All handlers are accumulated to allow multiple features to handle the same pattern\n * - Memory management: Uses WeakRef for wildcard handlers to prevent memory leaks\n * - Module isolation: Uses globalThis singleton so all bundled copies share the same state\n */\nimport type { CloudEvent } from \"./callback\";\nimport { matchesWildcardPattern } from \"./callback\";\n\n/**\n * Global key for dev handler state - Symbol.for ensures same symbol across all bundles\n */\nconst GLOBAL_KEY = Symbol.for(\"@vercel/queue.devHandlers\");\n\ntype DevRouteHandler = (request: Request) => Promise<Response>;\n\ninterface DevHandlerState {\n  devRouteHandlers: Map<\n    string,\n    {\n      routeHandler: DevRouteHandler;\n      topicPattern: string;\n    }\n  >;\n  wildcardRouteHandlers: Map<string, WeakRef<DevRouteHandler>[]>;\n}\n\n/**\n * Get or create the shared dev handler state\n * Uses globalThis to ensure all bundled copies share the same Maps\n */\nfunction getDevHandlerState(): DevHandlerState {\n  const g = globalThis as typeof globalThis & {\n    [GLOBAL_KEY]?: DevHandlerState;\n  };\n  if (!g[GLOBAL_KEY]) {\n    g[GLOBAL_KEY] = {\n      devRouteHandlers: new Map(),\n      wildcardRouteHandlers: new Map(),\n    };\n  }\n  return g[GLOBAL_KEY];\n}\n\nconst { devRouteHandlers, wildcardRouteHandlers } = getDevHandlerState();\n\n/**\n * Clean up dead WeakRefs from a specific pattern's handler list\n */\nfunction cleanupDeadRefs(\n  key: string,\n  refs: WeakRef<(request: Request) => Promise<Response>>[],\n): void {\n  const aliveRefs = refs.filter((ref) => ref.deref() !== undefined);\n  if (aliveRefs.length === 0) {\n    wildcardRouteHandlers.delete(key);\n  } else if (aliveRefs.length < refs.length) {\n    wildcardRouteHandlers.set(key, aliveRefs);\n  }\n}\n\n/**\n * Check if running in development mode\n */\nexport function isDevMode(): boolean {\n  return process.env.NODE_ENV === \"development\";\n}\n\n/**\n * Register the route handler and topic mappings for development mode\n * @internal\n */\nexport function registerDevRouteHandler(\n  routeHandler: (request: Request) => Promise<Response>,\n  handlers: { [topicName: string]: { [consumerGroup: string]: unknown } },\n): void {\n  // Register each topic:consumerGroup pair\n  for (const topicName in handlers) {\n    for (const consumerGroup in handlers[topicName]) {\n      const key = `${topicName}:${consumerGroup}`;\n\n      if (topicName.includes(\"*\")) {\n        // For wildcards, add to the wildcard handlers list\n        const existing = wildcardRouteHandlers.get(key) || [];\n\n        // Clean up dead refs first\n        cleanupDeadRefs(key, existing);\n        const cleanedRefs = wildcardRouteHandlers.get(key) || [];\n\n        // Add the new handler (no need to check for duplicates since routeHandler is always new)\n        const weakRef = new WeakRef(routeHandler);\n        cleanedRefs.push(weakRef);\n        wildcardRouteHandlers.set(key, cleanedRefs);\n      } else {\n        // For exact matches, latest handler wins (replaces any existing handler for this key)\n        devRouteHandlers.set(key, {\n          routeHandler,\n          topicPattern: topicName,\n        });\n      }\n    }\n  }\n}\n\n/**\n * Find all consumer groups for a topic across all registered handlers\n * @internal\n */\nexport function findDevConsumerGroups(topicName: string): Set<string> | null {\n  const consumerGroups = new Set<string>();\n\n  // Check exact match handlers\n  for (const [key, { topicPattern }] of devRouteHandlers.entries()) {\n    const [pattern, consumerGroup] = key.split(\":\");\n\n    // Only exact matches here\n    if (pattern === topicName) {\n      consumerGroups.add(consumerGroup);\n    }\n  }\n\n  // Check wildcard handlers\n  for (const [key, refs] of wildcardRouteHandlers.entries()) {\n    const [pattern, consumerGroup] = key.split(\":\");\n\n    if (matchesWildcardPattern(topicName, pattern)) {\n      // Clean up dead refs on-demand\n      cleanupDeadRefs(key, refs);\n      // Check if there are still alive handlers after cleanup\n      const cleanedRefs = wildcardRouteHandlers.get(key);\n      if (cleanedRefs && cleanedRefs.length > 0) {\n        consumerGroups.add(consumerGroup);\n      }\n    }\n  }\n\n  return consumerGroups.size > 0 ? consumerGroups : null;\n}\n\n/**\n * Find all route handlers that should receive a message for a topic\n * Returns a map of route handler to consumer groups it should process\n */\nfunction findRouteHandlersForTopic(\n  topicName: string,\n): Map<(request: Request) => Promise<Response>, Set<string>> {\n  const handlersMap = new Map<\n    (request: Request) => Promise<Response>,\n    Set<string>\n  >();\n\n  // Check exact match handlers\n  for (const [\n    key,\n    { routeHandler, topicPattern },\n  ] of devRouteHandlers.entries()) {\n    const [_, consumerGroup] = key.split(\":\");\n\n    // Only exact matches here (wildcards are handled separately)\n    if (topicPattern === topicName) {\n      if (!handlersMap.has(routeHandler)) {\n        handlersMap.set(routeHandler, new Set());\n      }\n      handlersMap.get(routeHandler)!.add(consumerGroup);\n    }\n  }\n\n  // Check wildcard handlers\n  for (const [key, refs] of wildcardRouteHandlers.entries()) {\n    const [pattern, consumerGroup] = key.split(\":\");\n\n    if (matchesWildcardPattern(topicName, pattern)) {\n      // Clean up dead refs on-demand\n      cleanupDeadRefs(key, refs);\n      // Get the cleaned refs and add all alive route handlers\n      const cleanedRefs = wildcardRouteHandlers.get(key) || [];\n      for (const ref of cleanedRefs) {\n        const routeHandler = ref.deref();\n        if (routeHandler) {\n          if (!handlersMap.has(routeHandler)) {\n            handlersMap.set(routeHandler, new Set());\n          }\n          handlersMap.get(routeHandler)!.add(consumerGroup);\n        }\n      }\n    }\n  }\n\n  return handlersMap;\n}\n\n/**\n * Create a mock CloudEvent request for development mode\n * @internal\n */\nfunction createMockCloudEventRequest(\n  topicName: string,\n  consumerGroup: string,\n  messageId: string,\n): Request {\n  const cloudEvent: CloudEvent = {\n    type: \"com.vercel.queue.v1beta\",\n    source: `/topic/${topicName}/consumer/${consumerGroup}`,\n    id: messageId,\n    datacontenttype: \"application/json\",\n    data: {\n      messageId,\n      queueName: topicName,\n      consumerGroup,\n    },\n    time: new Date().toISOString(),\n    specversion: \"1.0\",\n  };\n\n  return new Request(\"https://localhost/api/queue/callback\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/cloudevents+json\",\n    },\n    body: JSON.stringify(cloudEvent),\n  });\n}\n\n/**\n * Default delay for triggering dev callbacks (in milliseconds)\n */\nconst DEV_CALLBACK_DELAY = 1000;\n\n/**\n * Schedule a dev mode timeout re-trigger for a message\n * @internal\n */\nexport function scheduleDevTimeout(\n  topicName: string,\n  messageId: string,\n  timeoutSeconds: number,\n): void {\n  console.log(\n    `[Dev Mode] Message ${messageId} timed out for ${timeoutSeconds}s, will re-trigger`,\n  );\n\n  // Schedule re-trigger after the timeout period + 1s buffer to avoid race conditions\n  setTimeout(\n    () => {\n      console.log(\n        `[Dev Mode] Re-triggering callback for timed-out message ${messageId}`,\n      );\n      triggerDevCallbacks(topicName, messageId);\n    },\n    timeoutSeconds * 1000 + DEV_CALLBACK_DELAY,\n  );\n}\n\n/**\n * Trigger development mode callbacks for a topic\n * @internal\n */\nexport function triggerDevCallbacks(\n  topicName: string,\n  messageId: string,\n): void {\n  const handlersMap = findRouteHandlersForTopic(topicName);\n\n  if (handlersMap.size === 0) {\n    return; // No handlers for this topic\n  }\n\n  const consumerGroups = Array.from(\n    new Set(\n      Array.from(handlersMap.values()).flatMap((groups) => Array.from(groups)),\n    ),\n  );\n\n  console.log(\n    `[Dev Mode] Triggering local callbacks for topic \"${topicName}\" â†’ consumers: ${consumerGroups.join(\", \")}`,\n  );\n\n  setTimeout(async () => {\n    // Call each route handler with its consumer groups\n    for (const [routeHandler, consumerGroups] of handlersMap.entries()) {\n      for (const consumerGroup of consumerGroups) {\n        try {\n          const request = createMockCloudEventRequest(\n            topicName,\n            consumerGroup,\n            messageId,\n          );\n\n          const response = await routeHandler(request);\n\n          if (response.ok) {\n            try {\n              const responseData = (await response.json()) as {\n                status?: string;\n              };\n              if (responseData.status === \"success\") {\n                console.log(\n                  `[Dev Mode] Message processed for ${topicName}/${consumerGroup}`,\n                );\n              }\n            } catch (jsonError) {\n              console.error(\n                `[Dev Mode] Failed to parse success response for ${topicName}/${consumerGroup}:`,\n                jsonError,\n              );\n            }\n          } else {\n            try {\n              const errorData = (await response.json()) as { error?: string };\n              console.error(\n                `[Dev Mode] Failed to process message for ${topicName}/${consumerGroup}:`,\n                errorData.error || response.statusText,\n              );\n            } catch (jsonError) {\n              console.error(\n                `[Dev Mode] Failed to process message for ${topicName}/${consumerGroup}:`,\n                response.statusText,\n              );\n            }\n          }\n        } catch (error) {\n          console.error(\n            `[Dev Mode] Error triggering callback for ${topicName}/${consumerGroup}:`,\n            error,\n          );\n        }\n      }\n    }\n  }, DEV_CALLBACK_DELAY);\n}\n\n/**\n * Clear all dev handlers - for testing only\n * @internal\n */\nfunction clearDevHandlers(): void {\n  devRouteHandlers.clear();\n  wildcardRouteHandlers.clear();\n}\n\n// Export for testing\nif (process.env.NODE_ENV === \"test\" || process.env.VITEST) {\n  (globalThis as any).__clearDevHandlers = clearDevHandlers;\n}\n","import { QueueClient } from \"./client\";\nimport { JsonTransport } from \"./transports\";\nimport type {\n  ConsumerGroupOptions,\n  Message,\n  MessageHandler,\n  Transport,\n} from \"./types\";\nimport { isDevMode, scheduleDevTimeout } from \"./dev\";\n\n/**\n * Options for the consume method\n */\nexport interface ConsumeOptions {\n  /** The specific message ID to consume (if not provided, consumes next available message) */\n  messageId?: string;\n  /** Whether to skip downloading the payload (only allowed when messageId is provided) */\n  skipPayload?: boolean;\n}\n\n/**\n * A ConsumerGroup represents a named group of consumers that process messages from a topic\n */\nexport class ConsumerGroup<T = unknown> {\n  private client: QueueClient;\n  private topicName: string;\n  private consumerGroupName: string;\n  private visibilityTimeout: number;\n  private refreshInterval: number;\n  private transport: Transport<T>;\n\n  /**\n   * Create a new ConsumerGroup instance\n   * @param client QueueClient instance to use for API calls\n   * @param topicName Name of the topic to consume from\n   * @param consumerGroupName Name of the consumer group\n   * @param options Optional configuration\n   */\n  constructor(\n    client: QueueClient,\n    topicName: string,\n    consumerGroupName: string,\n    options: ConsumerGroupOptions<T> = {},\n  ) {\n    this.client = client;\n    this.topicName = topicName;\n    this.consumerGroupName = consumerGroupName;\n    this.visibilityTimeout = options.visibilityTimeoutSeconds || 30; // 30 seconds default\n    this.refreshInterval = options.refreshInterval || 10; // 10 seconds default\n    this.transport = options.transport || new JsonTransport<T>();\n  }\n\n  /**\n   * Starts a background loop that periodically extends the visibility timeout for a message.\n   * This prevents the message from becoming visible to other consumers while it's being processed.\n   *\n   * The extension loop runs every `refreshInterval` seconds and updates the message's\n   * visibility timeout to `visibilityTimeout` seconds from the current time.\n   *\n   * @param messageId - The unique identifier of the message to extend visibility for\n   * @param ticket - The receipt ticket that proves ownership of the message\n   * @returns A function that when called will stop the extension loop\n   *\n   * @remarks\n   * - The first extension attempt occurs after `refreshInterval` seconds, not immediately\n   * - If an extension fails, the loop terminates with an error logged to console\n   * - The returned stop function is idempotent - calling it multiple times is safe\n   * - By default, the stop function returns immediately without waiting for in-flight\n   * - Pass `true` to the stop function to wait for any in-flight extension to complete\n   */\n  private startVisibilityExtension(\n    messageId: string,\n    ticket: string,\n  ): (waitForCompletion?: boolean) => Promise<void> {\n    let isRunning = true;\n    let resolveLifecycle: () => void;\n    let timeoutId: NodeJS.Timeout | null = null;\n\n    // Promise that tracks the actual termination of the extension loop\n    const lifecyclePromise = new Promise<void>((resolve) => {\n      resolveLifecycle = resolve;\n    });\n\n    const extend = async (): Promise<void> => {\n      // Check if we should stop before attempting extension\n      if (!isRunning) {\n        resolveLifecycle();\n        return;\n      }\n\n      try {\n        // Extend the visibility timeout for another period\n        await this.client.changeVisibility({\n          queueName: this.topicName,\n          consumerGroup: this.consumerGroupName,\n          messageId,\n          ticket,\n          visibilityTimeoutSeconds: this.visibilityTimeout,\n        });\n\n        // Schedule next extension if still running\n        if (isRunning) {\n          timeoutId = setTimeout(() => extend(), this.refreshInterval * 1000);\n        } else {\n          // Signal that the loop has terminated after successful extension\n          resolveLifecycle();\n        }\n      } catch (error) {\n        // Log error and terminate the loop on failure\n        console.error(\n          `Failed to extend visibility for message ${messageId}:`,\n          error,\n        );\n        resolveLifecycle();\n      }\n    };\n\n    // Schedule the first extension attempt\n    timeoutId = setTimeout(() => extend(), this.refreshInterval * 1000);\n\n    // Return a function to stop the extension loop\n    return async (waitForCompletion: boolean = false) => {\n      // Signal the loop to stop\n      isRunning = false;\n\n      // Cancel any pending timeout to avoid unnecessary waiting\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n\n      // Only wait for in-flight operations if explicitly requested\n      if (waitForCompletion) {\n        // Wait for the loop to actually terminate\n        // This ensures any in-progress extension completes or fails\n        await lifecyclePromise;\n      } else {\n        // Resolve the lifecycle immediately for any waiting operations\n        // This allows immediate return without waiting for in-flight extensions\n        resolveLifecycle();\n      }\n    };\n  }\n\n  /**\n   * Process a single message with the given handler\n   * @param message The message to process\n   * @param handler Function to process the message\n   */\n  private async processMessage<TPayload>(\n    message: Message<TPayload>,\n    handler: MessageHandler<TPayload>,\n  ): Promise<void> {\n    const stopExtension = this.startVisibilityExtension(\n      message.messageId,\n      message.ticket,\n    );\n\n    try {\n      const result = await handler(message.payload, {\n        messageId: message.messageId,\n        deliveryCount: message.deliveryCount,\n        createdAt: message.createdAt,\n        topicName: this.topicName,\n        consumerGroup: this.consumerGroupName,\n      });\n      // Stop extensions immediately - we don't need to wait for in-flight extensions\n      // since we're about to delete or update the message visibility anyway\n      await stopExtension();\n\n      if (result && \"timeoutSeconds\" in result) {\n        // Handle timeout request - set new visibility timeout instead of deleting\n        await this.client.changeVisibility({\n          queueName: this.topicName,\n          consumerGroup: this.consumerGroupName,\n          messageId: message.messageId,\n          ticket: message.ticket,\n          visibilityTimeoutSeconds: result.timeoutSeconds,\n        });\n\n        // In development mode, schedule re-trigger after timeout period\n        if (isDevMode()) {\n          scheduleDevTimeout(\n            this.topicName,\n            message.messageId,\n            result.timeoutSeconds,\n          );\n        }\n      } else {\n        // Normal completion - delete the message\n        await this.client.deleteMessage({\n          queueName: this.topicName,\n          consumerGroup: this.consumerGroupName,\n          messageId: message.messageId,\n          ticket: message.ticket,\n        });\n      }\n    } catch (error) {\n      // Stop extensions immediately on error - fail fast without waiting\n      // for any in-flight extension attempts\n      await stopExtension();\n\n      // Clean up the message payload if the transport supports it and payload exists\n      // Only call finalize for non-void payloads since transport is typed for T, not void\n      if (\n        this.transport.finalize &&\n        message.payload !== undefined &&\n        message.payload !== null\n      ) {\n        try {\n          // Safe cast: when processMessage<T> is called, TPayload is T\n          // when processMessage<void> is called, payload is undefined so this won't execute\n          await this.transport.finalize(message.payload as T);\n        } catch (finalizeError) {\n          console.warn(\"Failed to finalize message payload:\", finalizeError);\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Consume the next available message from the queue\n   * @param handler Function to process the message\n   * @returns Promise that resolves when the message is processed\n   * @throws All the same errors as the underlying client methods\n   */\n  async consume(handler: MessageHandler<T>): Promise<void>;\n\n  /**\n   * Consume a specific message by its ID with full payload\n   * @param handler Function to process the message\n   * @param options Consume options with messageId specified\n   * @returns Promise that resolves when the message is processed\n   * @throws All the same errors as the underlying client methods\n   */\n  async consume(\n    handler: MessageHandler<T>,\n    options: { messageId: string; skipPayload?: false | undefined },\n  ): Promise<void>;\n\n  /**\n   * Consume a specific message by its ID without downloading the payload (metadata only)\n   * @param handler Function to process the message metadata (payload will be void)\n   * @param options Consume options with messageId and skipPayload specified\n   * @returns Promise that resolves when the message is processed\n   * @throws All the same errors as the underlying client methods\n   */\n  async consume(\n    handler: MessageHandler<void>,\n    options: { messageId: string; skipPayload: true },\n  ): Promise<void>;\n\n  async consume(\n    handler: MessageHandler<T> | MessageHandler<void>,\n    options?: ConsumeOptions,\n  ): Promise<void> {\n    if (options?.messageId) {\n      // Specific message mode\n      if (options.skipPayload) {\n        // Skip payload - like old handleMessage\n        const response = await this.client.receiveMessageById(\n          {\n            queueName: this.topicName,\n            consumerGroup: this.consumerGroupName,\n            messageId: options.messageId,\n            visibilityTimeoutSeconds: this.visibilityTimeout,\n            skipPayload: true,\n          },\n          this.transport,\n        );\n        await this.processMessage<void>(\n          response.message,\n          handler as MessageHandler<void>,\n        );\n      } else {\n        // With payload - like old receiveMessage\n        const response = await this.client.receiveMessageById(\n          {\n            queueName: this.topicName,\n            consumerGroup: this.consumerGroupName,\n            messageId: options.messageId,\n            visibilityTimeoutSeconds: this.visibilityTimeout,\n          },\n          this.transport,\n        );\n        await this.processMessage<T>(\n          response.message,\n          handler as MessageHandler<T>,\n        );\n      }\n    } else {\n      // Next message mode - like old receiveNextMessage\n      let messageFound = false;\n\n      for await (const message of this.client.receiveMessages<T>(\n        {\n          queueName: this.topicName,\n          consumerGroup: this.consumerGroupName,\n          visibilityTimeoutSeconds: this.visibilityTimeout,\n          limit: 1,\n        },\n        this.transport,\n      )) {\n        messageFound = true;\n        await this.processMessage<T>(message, handler as MessageHandler<T>);\n        break; // Process only one message\n      }\n\n      // If we get here without finding a message, the async generator\n      // should have already thrown QueueEmptyError, but just in case\n      if (!messageFound) {\n        throw new Error(\"No messages available\");\n      }\n    }\n  }\n\n  /**\n   * Get the consumer group name\n   */\n  get name(): string {\n    return this.consumerGroupName;\n  }\n\n  /**\n   * Get the topic name this consumer group is subscribed to\n   */\n  get topic(): string {\n    return this.topicName;\n  }\n}\n","import { QueueClient } from \"./client\";\nimport { ConsumerGroup } from \"./consumer-group\";\nimport { JsonTransport } from \"./transports\";\nimport type { ConsumerGroupOptions, PublishOptions, Transport } from \"./types\";\nimport { isDevMode, triggerDevCallbacks } from \"./dev\";\n\n/**\n * A Topic represents a named channel for publishing messages in a pub/sub pattern\n */\nexport class Topic<T = unknown> {\n  private client: QueueClient;\n  private topicName: string;\n  private transport: Transport<T>;\n\n  /**\n   * Create a new Topic instance\n   * @param client QueueClient instance to use for API calls\n   * @param topicName Name of the topic to work with\n   * @param transport Optional serializer/deserializer for the payload (defaults to JSON)\n   */\n  constructor(\n    client: QueueClient,\n    topicName: string,\n    transport?: Transport<T>,\n  ) {\n    this.client = client;\n    this.topicName = topicName;\n    this.transport = transport || new JsonTransport<T>();\n  }\n\n  /**\n   * Publish a message to the topic\n   * @param payload The data to publish\n   * @param options Optional publish options\n   * @returns An object containing the message ID\n   * @throws {BadRequestError} When request parameters are invalid\n   * @throws {UnauthorizedError} When authentication fails\n   * @throws {ForbiddenError} When access is denied (environment mismatch)\n   * @throws {InternalServerError} When server encounters an error\n   */\n  async publish(\n    payload: T,\n    options?: PublishOptions,\n  ): Promise<{ messageId: string }> {\n    const result = await this.client.sendMessage<T>(\n      {\n        queueName: this.topicName,\n        payload,\n        idempotencyKey: options?.idempotencyKey,\n        retentionSeconds: options?.retentionSeconds,\n        deploymentId: options?.deploymentId,\n      },\n      this.transport,\n    );\n\n    // In development mode, automatically trigger registered callbacks after 1s\n    if (isDevMode()) {\n      triggerDevCallbacks(this.topicName, result.messageId);\n    }\n\n    return { messageId: result.messageId };\n  }\n\n  /**\n   * Create a consumer group for this topic\n   * @param consumerGroupName Name of the consumer group\n   * @param options Optional configuration for the consumer group\n   * @returns A ConsumerGroup instance\n   */\n  consumerGroup<U = T>(\n    consumerGroupName: string,\n    options?: ConsumerGroupOptions<U>,\n  ): ConsumerGroup<U> {\n    // If no transport is provided in options, use the topic's transport if types match\n    const consumerOptions: ConsumerGroupOptions<U> = {\n      ...options,\n      transport:\n        options?.transport || (this.transport as unknown as Transport<U>),\n    };\n\n    return new ConsumerGroup<U>(\n      this.client,\n      this.topicName,\n      consumerGroupName,\n      consumerOptions,\n    );\n  }\n\n  /**\n   * Get the topic name\n   */\n  get name(): string {\n    return this.topicName;\n  }\n\n  /**\n   * Get the transport used by this topic\n   */\n  get serializer(): Transport<T> {\n    return this.transport;\n  }\n}\n","/**\n * Queue Callback utilities for handling incoming webhook payloads from Vercel triggers\n */\nimport { QueueClient } from \"./client\";\nimport { Topic } from \"./topic\";\nimport type { MessageHandler } from \"./types\";\nimport { isDevMode, registerDevRouteHandler } from \"./dev\";\n\n/**\n * CloudEvent specification for queue callbacks\n */\nexport interface CloudEvent<T = unknown> {\n  type: string;\n  source: string;\n  id: string;\n  datacontenttype: string;\n  data: T;\n  time?: string;\n  specversion?: string;\n}\n\n/**\n * Configuration object with handlers for different topics and consumer groups\n */\nexport type CallbackHandlers = {\n  [topicName: string]: { [consumerGroup: string]: MessageHandler };\n};\n\n/**\n * Parsed callback request information\n */\nexport type ParsedCallbackRequest = {\n  queueName: string;\n  consumerGroup: string;\n  messageId: string;\n};\n\n/**\n * Validate wildcard pattern according to rules:\n * - * may only appear once\n * - * may only appear at the end of the topic name\n */\nfunction validateWildcardPattern(pattern: string): boolean {\n  const firstIndex = pattern.indexOf(\"*\");\n  const lastIndex = pattern.lastIndexOf(\"*\");\n\n  // Rule 1: * may only appear once (first and last index should be the same)\n  if (firstIndex !== lastIndex) {\n    return false;\n  }\n\n  // If no asterisk found, this is not a wildcard pattern\n  if (firstIndex === -1) {\n    return false;\n  }\n\n  // Rule 2: * may only appear at the end (index should equal length - 1)\n  if (firstIndex !== pattern.length - 1) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Check if a topic name matches a wildcard pattern\n */\nexport function matchesWildcardPattern(\n  topicName: string,\n  pattern: string,\n): boolean {\n  // No need to validate here since patterns are pre-validated at setup time\n  const prefix = pattern.slice(0, -1); // Remove the trailing *\n  return topicName.startsWith(prefix);\n}\n\n/**\n * Find handler for a topic name, supporting wildcard patterns\n */\nfunction findTopicHandler(\n  queueName: string,\n  handlers: CallbackHandlers,\n): { [consumerGroup: string]: MessageHandler } | null {\n  // First, try exact match\n  const exactHandler = handlers[queueName];\n  if (exactHandler) {\n    return exactHandler;\n  }\n\n  // Then try wildcard patterns (all patterns are pre-validated)\n  for (const pattern in handlers) {\n    if (pattern.includes(\"*\") && matchesWildcardPattern(queueName, pattern)) {\n      return handlers[pattern];\n    }\n  }\n\n  return null;\n}\n\n/**\n * Parse and validate callback request using CloudEvent specification\n *\n * Extracts queue information from CloudEvent format and validates\n * that all required fields are present.\n *\n * @param request The incoming webhook request\n * @returns Parsed queue information\n * @throws Error if required fields are missing\n *\n * @example\n * ```typescript\n * // In Next.js API route\n * export async function POST(request: Request) {\n *   try {\n *     const { queueName, consumerGroup, messageId } = parseCallback(request);\n *\n *     // Use the parsed information...\n *     await myWorkflow.handleWebhook(queueName, consumerGroup, messageId);\n *\n *     return Response.json({ status: \"success\" });\n *   } catch (error) {\n *     return Response.json({ error: error.message }, { status: 400 });\n *   }\n * }\n * ```\n */\nexport async function parseCallback(\n  request: Request,\n): Promise<ParsedCallbackRequest> {\n  // Validate content type header\n  const contentType = request.headers.get(\"content-type\");\n  if (!contentType || !contentType.includes(\"application/cloudevents+json\")) {\n    throw new Error(\n      \"Invalid content type: expected 'application/cloudevents+json'\",\n    );\n  }\n\n  let cloudEvent: CloudEvent;\n\n  try {\n    cloudEvent = (await request.json()) as CloudEvent;\n  } catch (error) {\n    throw new Error(\"Failed to parse CloudEvent from request body\");\n  }\n\n  // Validate CloudEvent structure\n  if (\n    !cloudEvent.type ||\n    !cloudEvent.source ||\n    !cloudEvent.id ||\n    typeof cloudEvent.data !== \"object\" ||\n    cloudEvent.data == null\n  ) {\n    throw new Error(\"Invalid CloudEvent: missing required fields\");\n  }\n\n  // Validate CloudEvent type\n  if (cloudEvent.type !== \"com.vercel.queue.v1beta\") {\n    throw new Error(\n      `Invalid CloudEvent type: expected 'com.vercel.queue.v1beta', got '${cloudEvent.type}'`,\n    );\n  }\n\n  // Check for required data fields before destructuring\n  const missingFields: string[] = [];\n  if (!(\"queueName\" in cloudEvent.data)) missingFields.push(\"queueName\");\n  if (!(\"consumerGroup\" in cloudEvent.data))\n    missingFields.push(\"consumerGroup\");\n  if (!(\"messageId\" in cloudEvent.data)) missingFields.push(\"messageId\");\n  if (missingFields.length > 0) {\n    throw new Error(\n      `Missing required CloudEvent data fields: ${missingFields.join(\", \")}`,\n    );\n  }\n\n  const { messageId, queueName, consumerGroup } = cloudEvent.data as {\n    messageId: string;\n    queueName: string;\n    consumerGroup: string;\n  };\n\n  return {\n    queueName,\n    consumerGroup,\n    messageId,\n  };\n}\n\nexport function createCallbackHandler(\n  handlers: CallbackHandlers,\n  client: QueueClient,\n): (request: Request) => Promise<Response> {\n  // Validate all wildcard patterns at setup time\n  for (const topicPattern in handlers) {\n    if (topicPattern.includes(\"*\")) {\n      if (!validateWildcardPattern(topicPattern)) {\n        throw new Error(\n          `Invalid wildcard pattern \"${topicPattern}\": * may only appear once and must be at the end of the topic name`,\n        );\n      }\n    }\n  }\n\n  const routeHandler = async (request: Request): Promise<Response> => {\n    try {\n      // Parse the callback request\n      const { queueName, consumerGroup, messageId } =\n        await parseCallback(request);\n\n      // Find the topic handler\n      const topicHandler = findTopicHandler(queueName, handlers);\n\n      if (!topicHandler) {\n        const availableTopics = Object.keys(handlers).join(\", \");\n        return Response.json(\n          {\n            error: `No handler found for topic: ${queueName}`,\n            availableTopics,\n          },\n          { status: 404 },\n        );\n      }\n\n      // Find the consumer group handler\n      const consumerGroupHandler = topicHandler[consumerGroup];\n\n      if (!consumerGroupHandler) {\n        const availableGroups = Object.keys(topicHandler).join(\", \");\n        return Response.json(\n          {\n            error: `No handler found for consumer group \"${consumerGroup}\" in topic \"${queueName}\".`,\n            availableGroups,\n          },\n          { status: 404 },\n        );\n      }\n\n      // Use the provided client to process the message\n      const topic = new Topic(client, queueName);\n      const cg = topic.consumerGroup(consumerGroup);\n\n      await cg.consume(consumerGroupHandler, { messageId });\n\n      return Response.json({ status: \"success\" });\n    } catch (error) {\n      console.error(\"Queue callback error:\", error);\n\n      // Handle parsing errors with appropriate status codes\n      if (\n        error instanceof Error &&\n        (error.message.includes(\"Missing required CloudEvent data fields\") ||\n          error.message.includes(\"Invalid CloudEvent\") ||\n          error.message.includes(\"Invalid CloudEvent type\") ||\n          error.message.includes(\"Invalid content type\") ||\n          error.message.includes(\"Failed to parse CloudEvent\"))\n      ) {\n        return Response.json({ error: error.message }, { status: 400 });\n      }\n\n      return Response.json(\n        { error: \"Failed to process queue message\" },\n        { status: 500 },\n      );\n    }\n  };\n\n  // Register route handler and mappings in development mode\n  if (isDevMode()) {\n    registerDevRouteHandler(routeHandler, handlers);\n  }\n\n  return routeHandler;\n}\n\n/**\n * Simplified queue callback handler for Next.js route handlers\n *\n * Automatically extracts queue information from CloudEvent format\n * and routes to the appropriate handler based on topic and consumer group.\n *\n * @param handlers Object with topic-specific handlers organized by consumer groups\n * @param client Optional QueueClient instance to use. If not provided, a default client is created.\n * @returns A Next.js route handler function\n *\n * @example\n * ```typescript\n * // Single topic with multiple consumer groups\n * export const POST = handleCallback({\n *   \"image-processing\": {\n *     \"compress\": (message, metadata) => console.log(\"Compressing image\", message),\n *     \"resize\": (message, metadata) => console.log(\"Resizing image\", message),\n *   }\n * });\n *\n * // Multiple topics with consumer groups\n * export const POST = handleCallback({\n *   \"user-events\": {\n *     \"welcome\": (user, metadata) => console.log(\"Welcoming user\", user),\n *     \"analytics\": (user, metadata) => console.log(\"Tracking user\", user),\n *   },\n *   \"order-events\": {\n *     \"fulfillment\": (order, metadata) => console.log(\"Fulfilling order\", order),\n *     \"notifications\": (order, metadata) => console.log(\"Notifying order\", order),\n *   }\n * });\n * ```\n */\nexport function handleCallback(\n  handlers: CallbackHandlers,\n  client?: QueueClient,\n): (request: Request) => Promise<Response> {\n  return createCallbackHandler(handlers, client || new QueueClient());\n}\n"],"mappings":"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","names":["handleCallback","consumerGroups","handleCallback"]}