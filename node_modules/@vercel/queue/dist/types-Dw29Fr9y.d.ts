/**
 * Serializer/Deserializer interface for message payloads
 */
interface Transport<T = unknown> {
    /**
     * Serialize a value to a buffer or stream for transmission
     */
    serialize(value: T): Buffer | ReadableStream<Uint8Array>;
    /**
     * Deserialize a readable stream back to the original value
     */
    deserialize(stream: ReadableStream<Uint8Array>): Promise<T>;
    /**
     * Optional cleanup method for deserialized payloads that may contain resources
     * Should be called when the payload is no longer needed, especially in error cases
     * @param payload The deserialized payload to clean up
     */
    finalize?(payload: T): Promise<void>;
    /**
     * MIME type for this serialization format
     */
    contentType: string;
}
/**
 * Built-in JSON serializer/deserializer
 * This implementation reads the entire stream into memory for JSON parsing
 */
declare class JsonTransport<T = unknown> implements Transport<T> {
    readonly contentType = "application/json";
    readonly replacer?: Parameters<typeof JSON.parse>[1];
    readonly reviver?: Parameters<typeof JSON.parse>[1];
    constructor(options?: {
        replacer?: Parameters<typeof JSON.parse>[1];
        reviver?: Parameters<typeof JSON.parse>[1];
    });
    serialize(value: T): Buffer;
    deserialize(stream: ReadableStream<Uint8Array>): Promise<T>;
}
/**
 * Built-in Buffer serializer/deserializer (reads entire stream into a Buffer)
 */
declare class BufferTransport implements Transport<Buffer> {
    readonly contentType = "application/octet-stream";
    serialize(value: Buffer): Buffer;
    deserialize(stream: ReadableStream<Uint8Array>): Promise<Buffer>;
}
/**
 * Stream serializer/deserializer (pass-through for streaming binary data)
 * This is ideal for large payloads that don't need to be buffered in memory
 *
 * IMPORTANT: When using StreamTransport, you must call finalize(payload) when done
 * processing the message to prevent resource leaks, especially in error cases.
 * ConsumerGroup handles this automatically, but direct Client usage requires manual cleanup.
 *
 * Example usage:
 * ```typescript
 * const transport = new StreamTransport();
 * try {
 *   for await (const message of client.receiveMessages(options, transport)) {
 *     // Process the stream...
 *     const reader = message.payload.getReader();
 *     // ... handle stream data
 *   }
 * } catch (error) {
 *   // Cleanup is handled automatically by ConsumerGroup
 *   // or manually: await transport.finalize(message.payload);
 * }
 */
declare class StreamTransport implements Transport<ReadableStream<Uint8Array>> {
    readonly contentType = "application/octet-stream";
    serialize(value: ReadableStream<Uint8Array>): ReadableStream<Uint8Array>;
    deserialize(stream: ReadableStream<Uint8Array>): Promise<ReadableStream<Uint8Array>>;
    finalize(payload: ReadableStream<Uint8Array>): Promise<void>;
}

/**
 * Vercel Queue Service client types
 */

interface QueueClientOptions {
    /**
     * Base URL for the Vercel Queue Service API
     * Can also be set via VERCEL_QUEUE_BASE_URL environment variable
     * @default "https://vercel-queue.com"
     */
    baseUrl?: string;
    /**
     * Base path for API endpoints
     * Can also be set via VERCEL_QUEUE_BASE_PATH environment variable
     * @default "/api/v2/messages"
     */
    basePath?: string;
    /**
     * Authentication token for the Vercel Queue Service API
     * If not provided, the client will attempt to get a token via OIDC
     */
    token?: string;
    /**
     * Custom headers to include in all requests
     */
    headers?: Record<string, string>;
}
/**
 * Shared options for publishing messages
 */
interface PublishOptions {
    /**
     * Unique key to prevent duplicate message submissions
     * @default random UUID
     */
    idempotencyKey?: string;
    /**
     * Message retention time in seconds
     * @default 86400 (24 hours)
     * @min 60
     * @max 86400
     */
    retentionSeconds?: number;
    /**
     * Explicit deployment identifier to include in the `Vqs-Deployment-Id` header
     * If provided, this takes precedence over any value from the environment
     */
    deploymentId?: string;
}
interface SendMessageOptions<T = unknown> extends PublishOptions {
    /**
     * The queue name to send the message to
     */
    queueName: string;
    /**
     * The message payload
     */
    payload: T;
}
interface SendMessageResponse {
    /**
     * The generated message ID
     */
    messageId: string;
}
interface Message<T = unknown> {
    /**
     * The message ID
     */
    messageId: string;
    /**
     * The deserialized message payload
     * Note: If using streaming transports, ensure proper cleanup by calling transport.finalize(payload)
     * when done processing, especially in error cases
     */
    payload: T;
    /**
     * Number of times this message has been delivered
     */
    deliveryCount: number;
    /**
     * When the message was created
     */
    createdAt: Date;
    /**
     * MIME type of the message content
     */
    contentType: string;
    /**
     * Unique ticket for this message delivery (required for delete/patch operations)
     */
    ticket: string;
}
interface ReceiveMessagesOptions<T = unknown> {
    /**
     * The queue name to receive messages from
     */
    queueName: string;
    /**
     * Consumer group name
     */
    consumerGroup: string;
    /**
     * Time in seconds that messages will be invisible to other consumers
     * @default 900 (15 minutes)
     */
    visibilityTimeoutSeconds?: number;
    /**
     * Maximum number of messages to retrieve
     * @default 10
     * @max 10
     */
    limit?: number;
}
interface DeleteMessageOptions {
    /**
     * The queue name the message belongs to
     */
    queueName: string;
    /**
     * Consumer group name
     */
    consumerGroup: string;
    /**
     * The message ID to delete
     */
    messageId: string;
    /**
     * Ticket received from the message
     */
    ticket: string;
}
interface DeleteMessageResponse {
    /**
     * Whether the message was successfully deleted
     */
    deleted: boolean;
}
interface ChangeVisibilityOptions {
    /**
     * The queue name the message belongs to
     */
    queueName: string;
    /**
     * Consumer group name
     */
    consumerGroup: string;
    /**
     * The message ID to update
     */
    messageId: string;
    /**
     * Ticket received from the message
     */
    ticket: string;
    /**
     * New visibility timeout in seconds
     */
    visibilityTimeoutSeconds: number;
}
interface ChangeVisibilityResponse {
    /**
     * Whether the visibility was successfully updated
     */
    updated: boolean;
}
/**
 * Result indicating the message should be timed out for retry later
 */
interface MessageTimeoutResult {
    /**
     * Time in seconds before the message becomes visible again
     */
    timeoutSeconds: number;
}
/**
 * Result returned by message handlers
 */
type MessageHandlerResult = void | MessageTimeoutResult;
/**
 * Message metadata provided to handlers
 */
interface MessageMetadata {
    messageId: string;
    deliveryCount: number;
    createdAt: Date;
    topicName: string;
    consumerGroup: string;
}
/**
 * Message handler function type
 */
type MessageHandler<T = unknown> = (message: T, metadata: MessageMetadata) => Promise<MessageHandlerResult> | MessageHandlerResult;
/**
 * Options for creating a ConsumerGroup instance
 */
interface ConsumerGroupOptions<T = unknown> {
    /**
     * Serializer/deserializer for the payload
     * @default JsonTransport instance
     */
    transport?: Transport<T>;
    /**
     * Time in seconds that messages will be invisible to other consumers
     * @default 30
     */
    visibilityTimeoutSeconds?: number;
    /**
     * How often to refresh the visibility timeout during processing (in seconds)
     * @default 10
     */
    refreshInterval?: number;
}
interface ReceiveMessageByIdOptions<T = unknown> {
    /**
     * The queue name to receive the message from
     */
    queueName: string;
    /**
     * Consumer group name
     */
    consumerGroup: string;
    /**
     * The message ID to retrieve
     */
    messageId: string;
    /**
     * Time in seconds that the message will be invisible to other consumers
     * @default 900 (15 minutes)
     */
    visibilityTimeoutSeconds?: number;
    /**
     * Skip payload content and only return message metadata
     * When true, the server returns a 204 status with headers containing message metadata
     * @default false
     */
    skipPayload?: boolean;
}
interface ReceiveMessageByIdResponse<T = unknown, TSkipPayload extends boolean = false> {
    message: TSkipPayload extends true ? Message<void> : Message<T>;
}
/**
 * Error thrown when a message is not found (404)
 */
declare class MessageNotFoundError extends Error {
    constructor(messageId: string);
}
/**
 * Error thrown when a message is not available for processing (409)
 * This can happen when the message is in the wrong state, already claimed, etc.
 */
declare class MessageNotAvailableError extends Error {
    constructor(messageId: string, reason?: string);
}
/**
 * Error thrown when message data is corrupted or can't be parsed
 */
declare class MessageCorruptedError extends Error {
    constructor(messageId: string, reason: string);
}
/**
 * Error thrown when there are no messages available in the queue (204)
 */
declare class QueueEmptyError extends Error {
    constructor(queueName: string, consumerGroup: string);
}
/**
 * Error thrown when a message is temporarily locked (423)
 */
declare class MessageLockedError extends Error {
    readonly retryAfter?: number;
    constructor(messageId: string, retryAfter?: number);
}
/**
 * Error thrown when authentication fails (401)
 */
declare class UnauthorizedError extends Error {
    constructor(message?: string);
}
/**
 * Error thrown when access is forbidden (403)
 */
declare class ForbiddenError extends Error {
    constructor(message?: string);
}
/**
 * Error thrown for bad requests (400)
 */
declare class BadRequestError extends Error {
    constructor(message: string);
}
/**
 * Error thrown for internal server errors (500)
 */
declare class InternalServerError extends Error {
    constructor(message?: string);
}
/**
 * Error thrown when batch limit parameter is invalid
 */
declare class InvalidLimitError extends Error {
    constructor(limit: number, min?: number, max?: number);
}

export { BufferTransport as B, type ChangeVisibilityOptions as C, type DeleteMessageOptions as D, ForbiddenError as F, InternalServerError as I, JsonTransport as J, type Message as M, type PublishOptions as P, type QueueClientOptions as Q, type ReceiveMessagesOptions as R, type SendMessageOptions as S, type Transport as T, UnauthorizedError as U, type SendMessageResponse as a, type ReceiveMessageByIdOptions as b, type ReceiveMessageByIdResponse as c, type DeleteMessageResponse as d, type ChangeVisibilityResponse as e, type MessageHandler as f, type ConsumerGroupOptions as g, StreamTransport as h, BadRequestError as i, InvalidLimitError as j, MessageCorruptedError as k, MessageLockedError as l, MessageNotAvailableError as m, MessageNotFoundError as n, QueueEmptyError as o, type MessageHandlerResult as p, type MessageMetadata as q, type MessageTimeoutResult as r };
