import { z } from 'zod/v4';
export declare const QueuePrefix: z.ZodUnion<readonly [z.ZodLiteral<"__wkf_step_">, z.ZodLiteral<"__wkf_workflow_">]>;
export type QueuePrefix = z.infer<typeof QueuePrefix>;
export declare const ValidQueueName: z.ZodTemplateLiteral<`__wkf_step_${string}` | `__wkf_workflow_${string}`>;
export type ValidQueueName = z.infer<typeof ValidQueueName>;
export declare const MessageId: z.core.$ZodBranded<z.ZodString, "MessageId">;
export type MessageId = z.infer<typeof MessageId>;
/**
 * OpenTelemetry trace context for distributed tracing
 */
export declare const TraceCarrierSchema: z.ZodRecord<z.ZodString, z.ZodString>;
export type TraceCarrier = z.infer<typeof TraceCarrierSchema>;
export declare const WorkflowInvokePayloadSchema: z.ZodObject<{
    runId: z.ZodString;
    traceCarrier: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    requestedAt: z.ZodOptional<z.ZodCoercedDate<unknown>>;
}, z.core.$strip>;
export declare const StepInvokePayloadSchema: z.ZodObject<{
    workflowName: z.ZodString;
    workflowRunId: z.ZodString;
    workflowStartedAt: z.ZodNumber;
    stepId: z.ZodString;
    traceCarrier: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    requestedAt: z.ZodOptional<z.ZodCoercedDate<unknown>>;
}, z.core.$strip>;
export type WorkflowInvokePayload = z.infer<typeof WorkflowInvokePayloadSchema>;
export type StepInvokePayload = z.infer<typeof StepInvokePayloadSchema>;
export type HealthCheckPayload = z.infer<typeof HealthCheckPayloadSchema>;
/**
 * Health check payload - used to verify that the queue pipeline
 * can deliver messages to workflow/step endpoints.
 */
export declare const HealthCheckPayloadSchema: z.ZodObject<{
    __healthCheck: z.ZodLiteral<true>;
    correlationId: z.ZodString;
}, z.core.$strip>;
export declare const QueuePayloadSchema: z.ZodUnion<readonly [z.ZodObject<{
    runId: z.ZodString;
    traceCarrier: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    requestedAt: z.ZodOptional<z.ZodCoercedDate<unknown>>;
}, z.core.$strip>, z.ZodObject<{
    workflowName: z.ZodString;
    workflowRunId: z.ZodString;
    workflowStartedAt: z.ZodNumber;
    stepId: z.ZodString;
    traceCarrier: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    requestedAt: z.ZodOptional<z.ZodCoercedDate<unknown>>;
}, z.core.$strip>, z.ZodObject<{
    __healthCheck: z.ZodLiteral<true>;
    correlationId: z.ZodString;
}, z.core.$strip>]>;
export type QueuePayload = z.infer<typeof QueuePayloadSchema>;
export interface QueueOptions {
    deploymentId?: string;
    idempotencyKey?: string;
}
export interface Queue {
    getDeploymentId(): Promise<string>;
    /**
     * Enqueues a message to the specified queue.
     *
     * @param queueName - The name of the queue to which the message will be sent.
     * @param message - The content of the message to be sent to the queue.
     * @param opts - Optional parameters for the queue operation.
     */
    queue(queueName: ValidQueueName, message: QueuePayload, opts?: QueueOptions): Promise<{
        messageId: MessageId;
    }>;
    /**
     * Creates an HTTP queue handler for processing messages from a specific queue.
     */
    createQueueHandler(queueNamePrefix: QueuePrefix, handler: (message: unknown, meta: {
        attempt: number;
        queueName: ValidQueueName;
        messageId: MessageId;
    }) => Promise<void | {
        timeoutSeconds: number;
    }>): (req: Request) => Promise<Response>;
}
//# sourceMappingURL=queue.d.ts.map