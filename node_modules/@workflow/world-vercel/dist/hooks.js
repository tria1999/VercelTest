import { HookSchema, PaginatedResponseSchema } from '@workflow/world';
import z from 'zod';
import { DEFAULT_RESOLVE_DATA_OPTION, dateToStringReplacer, makeRequest, } from './utils.js';
// Helper to filter hook data based on resolveData setting
function filterHookData(hook, resolveData) {
    if (resolveData === 'none') {
        const { metadataRef: _metadataRef, ...rest } = hook;
        return rest;
    }
    return hook;
}
const HookWithRefsSchema = HookSchema.omit({
    metadata: true,
}).extend({
    metadataRef: z.any().optional(),
});
export async function listHooks(params, config) {
    const { runId, pagination, resolveData = DEFAULT_RESOLVE_DATA_OPTION, } = params;
    const searchParams = new URLSearchParams();
    if (pagination?.limit)
        searchParams.set('limit', pagination.limit.toString());
    if (pagination?.cursor)
        searchParams.set('cursor', pagination.cursor);
    if (pagination?.sortOrder)
        searchParams.set('sortOrder', pagination.sortOrder);
    // Map resolveData to internal RemoteRefBehavior
    const remoteRefBehavior = resolveData === 'none' ? 'lazy' : 'resolve';
    searchParams.set('remoteRefBehavior', remoteRefBehavior);
    if (runId)
        searchParams.set('runId', runId);
    const queryString = searchParams.toString();
    const endpoint = `/v1/hooks${queryString ? `?${queryString}` : ''}`;
    const response = (await makeRequest({
        endpoint,
        options: { method: 'GET' },
        config,
        schema: PaginatedResponseSchema(remoteRefBehavior === 'lazy' ? HookWithRefsSchema : HookSchema),
    }));
    return {
        ...response,
        data: response.data.map((hook) => filterHookData(hook, resolveData)),
    };
}
export async function getHook(hookId, params, config) {
    const resolveData = params?.resolveData || 'all';
    const endpoint = `/v1/hooks/${hookId}`;
    const hook = await makeRequest({
        endpoint,
        options: { method: 'GET' },
        config,
        schema: HookSchema,
    });
    return filterHookData(hook, resolveData);
}
export async function createHook(runId, data, config) {
    return makeRequest({
        endpoint: `/v1/hooks/create`,
        options: {
            method: 'POST',
            body: JSON.stringify({
                runId,
                ...data,
            }, dateToStringReplacer),
        },
        config,
        schema: HookSchema,
    });
}
export async function getHookByToken(token, config) {
    return makeRequest({
        endpoint: `/v1/hooks/by-token?token=${encodeURIComponent(token)}`,
        options: {
            method: 'GET',
        },
        config,
        schema: HookSchema,
    });
}
export async function disposeHook(hookId, config) {
    return makeRequest({
        endpoint: `/v1/hooks/${hookId}`,
        options: { method: 'DELETE' },
        config,
        schema: HookSchema,
    });
}
//# sourceMappingURL=hooks.js.map