import { type StructuredError } from '@workflow/world';
import type { z } from 'zod';
export interface APIConfig {
    baseUrl?: string;
    token?: string;
    headers?: RequestInit['headers'];
    skipProxy?: boolean;
    projectConfig?: {
        projectId?: string;
        teamId?: string;
        environment?: string;
    };
}
export declare const DEFAULT_RESOLVE_DATA_OPTION = "all";
export declare function dateToStringReplacer(_key: string, value: unknown): unknown;
/**
 * Helper to serialize error into a JSON string in the error field.
 * The error field can be either:
 * - A plain string (legacy format, just the error message)
 * - A JSON string with { message, stack, code } (new format)
 */
export declare function serializeError<T extends {
    error?: StructuredError;
}>(data: T): Omit<T, 'error'> & {
    error?: string;
};
/**
 * Helper to deserialize error field from the backend into a StructuredError object.
 * Handles backwards compatibility:
 * - If error is a JSON string with {message, stack, code} → parse into StructuredError
 * - If error is a plain string → treat as error message with no stack
 * - If no error → undefined
 *
 * This function transforms objects from wire format (where error is a JSON string)
 * to domain format (where error is a StructuredError object). The generic type
 * parameter should be the expected output type (WorkflowRun or Step).
 *
 * Note: The type assertion is necessary because the wire format types from Zod schemas
 * have `error?: string` while the domain types have complex error types (e.g., discriminated
 * unions with `error: void` or `error: StructuredError` depending on status), but the
 * transformation preserves all other fields correctly.
 */
export declare function deserializeError<T extends Record<string, any>>(obj: any): T;
export interface HttpConfig {
    baseUrl: string;
    headers: Headers;
    usingProxy: boolean;
}
export declare const getHttpUrl: (config?: APIConfig) => {
    baseUrl: string;
    usingProxy: boolean;
};
export declare const getHeaders: (config?: APIConfig) => Headers;
export declare function getHttpConfig(config?: APIConfig): Promise<HttpConfig>;
export declare function makeRequest<T>({ endpoint, options, config, schema, }: {
    endpoint: string;
    options?: RequestInit;
    config?: APIConfig;
    schema: z.ZodSchema<T>;
}): Promise<T>;
//# sourceMappingURL=utils.d.ts.map