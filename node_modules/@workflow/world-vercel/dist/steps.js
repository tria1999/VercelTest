import { PaginatedResponseSchema, StepSchema, } from '@workflow/world';
import { z } from 'zod';
import { DEFAULT_RESOLVE_DATA_OPTION, dateToStringReplacer, deserializeError, makeRequest, serializeError, } from './utils.js';
/**
 * Wire format schema for steps coming from the backend.
 * The backend returns error as a JSON string, not an object, so we need
 * a schema that accepts the wire format before deserialization.
 *
 * This is used for validation in makeRequest(), then deserializeStepError()
 * transforms the string into the expected StructuredError object.
 */
const StepWireSchema = StepSchema.omit({
    error: true,
}).extend({
    // Backend returns error as a JSON string, not an object
    error: z.string().optional(),
});
// Wire schema for lazy mode with refs instead of data
const StepWireWithRefsSchema = StepWireSchema.omit({
    input: true,
    output: true,
}).extend({
    // We discard the results of the refs, so we don't care about the type here
    inputRef: z.any().optional(),
    outputRef: z.any().optional(),
    input: z.array(z.any()).optional(),
    output: z.any().optional(),
});
// Helper to filter step data based on resolveData setting
function filterStepData(step, resolveData) {
    if (resolveData === 'none') {
        const { inputRef: _inputRef, outputRef: _outputRef, ...rest } = step;
        const deserialized = deserializeError(rest);
        return {
            ...deserialized,
            input: [],
            output: undefined,
        };
    }
    return deserializeError(step);
}
// Functions
export async function listWorkflowRunSteps(params, config) {
    const { runId, pagination, resolveData = DEFAULT_RESOLVE_DATA_OPTION, } = params;
    const searchParams = new URLSearchParams();
    if (pagination?.cursor)
        searchParams.set('cursor', pagination.cursor);
    if (pagination?.limit)
        searchParams.set('limit', pagination.limit.toString());
    if (pagination?.sortOrder)
        searchParams.set('sortOrder', pagination.sortOrder);
    // Map resolveData to internal RemoteRefBehavior
    const remoteRefBehavior = resolveData === 'none' ? 'lazy' : 'resolve';
    searchParams.set('remoteRefBehavior', remoteRefBehavior);
    const queryString = searchParams.toString();
    const endpoint = `/v1/runs/${runId}/steps${queryString ? `?${queryString}` : ''}`;
    const response = (await makeRequest({
        endpoint,
        options: { method: 'GET' },
        config,
        schema: PaginatedResponseSchema(remoteRefBehavior === 'lazy' ? StepWireWithRefsSchema : StepWireSchema),
    }));
    return {
        ...response,
        data: response.data.map((step) => filterStepData(step, resolveData)),
    };
}
export async function createStep(runId, data, config) {
    const step = await makeRequest({
        endpoint: `/v1/runs/${runId}/steps`,
        options: {
            method: 'POST',
            body: JSON.stringify(data, dateToStringReplacer),
        },
        config,
        schema: StepWireSchema,
    });
    return deserializeError(step);
}
export async function updateStep(runId, stepId, data, config) {
    const serialized = serializeError(data);
    const step = await makeRequest({
        endpoint: `/v1/runs/${runId}/steps/${stepId}`,
        options: {
            method: 'PUT',
            body: JSON.stringify(serialized, dateToStringReplacer),
        },
        config,
        schema: StepWireSchema,
    });
    return deserializeError(step);
}
export async function getStep(runId, stepId, params, config) {
    const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION;
    const remoteRefBehavior = resolveData === 'none' ? 'lazy' : 'resolve';
    const searchParams = new URLSearchParams();
    searchParams.set('remoteRefBehavior', remoteRefBehavior);
    const queryString = searchParams.toString();
    const endpoint = runId
        ? `/v1/runs/${runId}/steps/${stepId}${queryString ? `?${queryString}` : ''}`
        : `/v1/steps/${stepId}${queryString ? `?${queryString}` : ''}`;
    const step = await makeRequest({
        endpoint,
        options: { method: 'GET' },
        config,
        schema: (remoteRefBehavior === 'lazy'
            ? StepWireWithRefsSchema
            : StepWireSchema),
    });
    return filterStepData(step, resolveData);
}
//# sourceMappingURL=steps.js.map