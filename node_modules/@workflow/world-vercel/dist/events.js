import { EventSchema, EventTypeSchema, PaginatedResponseSchema, } from '@workflow/world';
import z from 'zod';
import { DEFAULT_RESOLVE_DATA_OPTION, dateToStringReplacer, makeRequest, } from './utils.js';
// Helper to filter event data based on resolveData setting
function filterEventData(event, resolveData) {
    if (resolveData === 'none') {
        const { eventData: _eventData, ...rest } = event;
        return rest;
    }
    return event;
}
// Would usually "EventSchema.omit({ eventData: true })" but that doesn't work
// on zod unions. Re-creating the schema manually.
const EventWithRefsSchema = z.object({
    eventId: z.string(),
    runId: z.string(),
    eventType: EventTypeSchema,
    correlationId: z.string().optional(),
    eventDataRef: z.any().optional(),
    createdAt: z.coerce.date(),
});
// Functions
export async function getWorkflowRunEvents(params, config) {
    const searchParams = new URLSearchParams();
    const { pagination, resolveData = DEFAULT_RESOLVE_DATA_OPTION } = params;
    let runId;
    let correlationId;
    if ('runId' in params) {
        runId = params.runId;
    }
    else {
        correlationId = params.correlationId;
    }
    if (!runId && !correlationId) {
        throw new Error('Either runId or correlationId must be provided');
    }
    if (pagination?.limit)
        searchParams.set('limit', pagination.limit.toString());
    if (pagination?.cursor)
        searchParams.set('cursor', pagination.cursor);
    if (pagination?.sortOrder)
        searchParams.set('sortOrder', pagination.sortOrder);
    if (correlationId)
        searchParams.set('correlationId', correlationId);
    const remoteRefBehavior = resolveData === 'none' ? 'lazy' : 'resolve';
    searchParams.set('remoteRefBehavior', remoteRefBehavior);
    const queryString = searchParams.toString();
    const query = queryString ? `?${queryString}` : '';
    const endpoint = correlationId
        ? `/v1/events${query}`
        : `/v1/runs/${runId}/events${query}`;
    const response = (await makeRequest({
        endpoint,
        options: { method: 'GET' },
        config,
        schema: PaginatedResponseSchema(remoteRefBehavior === 'lazy' ? EventWithRefsSchema : EventSchema),
    }));
    return {
        ...response,
        data: response.data.map((event) => filterEventData(event, resolveData)),
    };
}
export async function createWorkflowRunEvent(id, data, params, config) {
    const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION;
    const event = await makeRequest({
        endpoint: `/v1/runs/${id}/events`,
        options: {
            method: 'POST',
            body: JSON.stringify(data, dateToStringReplacer),
        },
        config,
        schema: EventSchema,
    });
    return filterEventData(event, resolveData);
}
//# sourceMappingURL=events.js.map