import type { PaginatedResponse } from '@workflow/world';
import { z } from 'zod';
/**
 * Clear the created files cache. Useful for testing or when files are deleted externally.
 */
export declare function clearCreatedFilesCache(): void;
export declare function ulidToDate(maybeUlid: string): Date | null;
export declare function ensureDir(dirPath: string): Promise<void>;
interface WriteOptions {
    overwrite?: boolean;
}
export declare function writeJSON(filePath: string, data: any, opts?: WriteOptions): Promise<void>;
/**
 * Writes data to a file using atomic write-rename pattern.
 *
 * Note: While this function uses temp files to avoid partial writes,
 * it does not provide protection against concurrent writes from multiple
 * processes. In a multi-writer scenario, the last writer wins.
 * For production use with multiple writers, consider using a proper
 * database or locking mechanism.
 */
export declare function write(filePath: string, data: string | Buffer, opts?: WriteOptions): Promise<void>;
export declare function readJSON<T>(filePath: string, decoder: z.ZodType<T>): Promise<T | null>;
export declare function readBuffer(filePath: string): Promise<Buffer>;
export declare function deleteJSON(filePath: string): Promise<void>;
export declare function listJSONFiles(dirPath: string): Promise<string[]>;
interface PaginatedFileSystemQueryConfig<T> {
    directory: string;
    schema: z.ZodType<T>;
    filePrefix?: string;
    filter?: (item: T) => boolean;
    sortOrder?: 'asc' | 'desc';
    limit?: number;
    cursor?: string;
    getCreatedAt(filename: string): Date | null;
    getId?(item: T): string;
}
export declare function paginatedFileSystemQuery<T extends {
    createdAt: Date;
}>(config: PaginatedFileSystemQueryConfig<T>): Promise<PaginatedResponse<T>>;
export {};
//# sourceMappingURL=fs.d.ts.map