import { type PromiseWithResolvers } from '@workflow/utils';
/**
 * Polling interval (in ms) for lock release detection.
 *
 * The Web Streams API does not expose an event for "lock released but stream
 * still open"; we can only distinguish that state by periodically attempting
 * to acquire a reader/writer. For that reason we use polling instead of a
 * fully event-driven approach here.
 *
 * 100ms is a compromise between:
 * - Latency: how quickly we notice that the user has released their lock, and
 * - Cost/CPU usage: how often timers fire, especially with many concurrent
 *   streams or in serverless environments where billed time matters.
 *
 * This value should only be changed with care, as decreasing it will
 * increase polling frequency (and thus potential cost), while increasing it
 * will add worst-case delay before the `done` promise resolves after a lock
 * is released.
 */
export declare const LOCK_POLL_INTERVAL_MS = 100;
/**
 * State tracker for flushable stream operations.
 * Resolves when either:
 * 1. Stream completes (close/error), OR
 * 2. Lock is released AND all pending operations are flushed
 *
 * Note: `doneResolved` and `streamEnded` are separate:
 * - `doneResolved`: The `done` promise has been resolved (step can complete)
 * - `streamEnded`: The underlying stream has actually closed/errored
 *
 * Once `doneResolved` is set to true, the `done` promise will not resolve
 * again. Re-acquiring locks after release is not supported as a way to
 * trigger additional completion signaling.
 */
export interface FlushableStreamState extends PromiseWithResolvers<void> {
    /** Number of write operations currently in flight to the server */
    pendingOps: number;
    /** Whether the `done` promise has been resolved */
    doneResolved: boolean;
    /** Whether the underlying stream has actually closed/errored */
    streamEnded: boolean;
    /** Interval ID for writable lock polling (if active) */
    writablePollingInterval?: ReturnType<typeof setInterval>;
    /** Interval ID for readable lock polling (if active) */
    readablePollingInterval?: ReturnType<typeof setInterval>;
}
export declare function createFlushableState(): FlushableStreamState;
/**
 * Polls a WritableStream to check if the user has released their lock.
 * Resolves the done promise when lock is released and no pending ops remain.
 *
 * Note: Only resolves if stream is unlocked but NOT closed. If the user closes
 * the stream, the pump will handle resolution via the stream ending naturally.
 *
 * Protection: If polling is already active on this state, the existing interval
 * is used to avoid creating multiple simultaneous polling operations.
 */
export declare function pollWritableLock(writable: WritableStream, state: FlushableStreamState): void;
/**
 * Polls a ReadableStream to check if the user has released their lock.
 * Resolves the done promise when lock is released and no pending ops remain.
 *
 * Note: Only resolves if stream is unlocked but NOT closed. If the user closes
 * the stream, the pump will handle resolution via the stream ending naturally.
 *
 * Protection: If polling is already active on this state, the existing interval
 * is used to avoid creating multiple simultaneous polling operations.
 */
export declare function pollReadableLock(readable: ReadableStream, state: FlushableStreamState): void;
/**
 * Creates a flushable pipe from a ReadableStream to a WritableStream.
 * Unlike pipeTo(), this resolves when:
 * 1. The source stream completes (close/error), OR
 * 2. The user releases their lock on userStream AND all pending writes are flushed
 *
 * @param source - The readable stream to read from (e.g., transform's readable)
 * @param sink - The writable stream to write to (e.g., server writable)
 * @param state - The flushable state tracker
 * @returns Promise that resolves when stream ends (not when done promise resolves)
 */
export declare function flushablePipe(source: ReadableStream, sink: WritableStream, state: FlushableStreamState): Promise<void>;
//# sourceMappingURL=flushable-stream.d.ts.map