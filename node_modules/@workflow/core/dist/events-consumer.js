import { eventsLogger } from './logger.js';
export var EventConsumerResult;
(function (EventConsumerResult) {
    /**
     * Callback consumed the event, but should not be removed from the callbacks list
     */
    EventConsumerResult[EventConsumerResult["Consumed"] = 0] = "Consumed";
    /**
     * Callback did not consume the event, so it should be passed to the next callback
     */
    EventConsumerResult[EventConsumerResult["NotConsumed"] = 1] = "NotConsumed";
    /**
     * Callback consumed the event, and should be removed from the callbacks list
     */
    EventConsumerResult[EventConsumerResult["Finished"] = 2] = "Finished";
})(EventConsumerResult || (EventConsumerResult = {}));
export class EventsConsumer {
    eventIndex;
    events = [];
    callbacks = [];
    constructor(events) {
        this.events = events;
        this.eventIndex = 0;
        eventsLogger.debug('EventsConsumer initialized', { events });
    }
    /**
     * Registers a callback function to be called after an event has been consumed
     * by a different callback. The callback can return:
     *  - `EventConsumerResult.Consumed` the event is considered consumed and will not be passed to any other callback, but the callback will remain in the callbacks list
     *  - `EventConsumerResult.NotConsumed` the event is passed to the next callback
     *  - `EventConsumerResult.Finished` the event is considered consumed and the callback is removed from the callbacks list
     *
     * @param fn - The callback function to register.
     */
    subscribe(fn) {
        this.callbacks.push(fn);
        process.nextTick(this.consume);
    }
    consume = () => {
        const currentEvent = this.events[this.eventIndex] ?? null;
        for (let i = 0; i < this.callbacks.length; i++) {
            const callback = this.callbacks[i];
            let handled = EventConsumerResult.NotConsumed;
            try {
                handled = callback(currentEvent);
            }
            catch (error) {
                eventsLogger.error('EventConsumer callback threw an error', { error });
                // Hopefully shouldn't happen, but we don't want to block the workflow
                console.error('EventConsumer callback threw an error', error);
            }
            eventsLogger.debug('EventConsumer callback result', {
                handled: EventConsumerResult[handled],
                eventIndex: this.eventIndex,
                eventId: currentEvent?.eventId,
            });
            if (handled === EventConsumerResult.Consumed ||
                handled === EventConsumerResult.Finished) {
                // consumer handled this event, so increase the event index
                this.eventIndex++;
                // remove the callback if it has finished
                if (handled === EventConsumerResult.Finished) {
                    this.callbacks.splice(i, 1);
                }
                // continue to the next event
                process.nextTick(this.consume);
                return;
            }
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZlbnRzLWNvbnN1bWVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2V2ZW50cy1jb25zdW1lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBRTNDLE1BQU0sQ0FBTixJQUFZLG1CQWFYO0FBYkQsV0FBWSxtQkFBbUI7SUFDN0I7O09BRUc7SUFDSCxxRUFBUSxDQUFBO0lBQ1I7O09BRUc7SUFDSCwyRUFBVyxDQUFBO0lBQ1g7O09BRUc7SUFDSCxxRUFBUSxDQUFBO0FBQ1YsQ0FBQyxFQWJXLG1CQUFtQixLQUFuQixtQkFBbUIsUUFhOUI7QUFJRCxNQUFNLE9BQU8sY0FBYztJQUN6QixVQUFVLENBQVM7SUFDVixNQUFNLEdBQVksRUFBRSxDQUFDO0lBQ3JCLFNBQVMsR0FBNEIsRUFBRSxDQUFDO0lBRWpELFlBQVksTUFBZTtRQUN6QixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQztRQUVwQixZQUFZLENBQUMsS0FBSyxDQUFDLDRCQUE0QixFQUFFLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSCxTQUFTLENBQUMsRUFBeUI7UUFDakMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDeEIsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVPLE9BQU8sR0FBRyxHQUFHLEVBQUU7UUFDckIsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksSUFBSSxDQUFDO1FBQzFELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQy9DLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkMsSUFBSSxPQUFPLEdBQUcsbUJBQW1CLENBQUMsV0FBVyxDQUFDO1lBQzlDLElBQUksQ0FBQztnQkFDSCxPQUFPLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQ25DLENBQUM7WUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO2dCQUNmLFlBQVksQ0FBQyxLQUFLLENBQUMsdUNBQXVDLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO2dCQUN2RSxzRUFBc0U7Z0JBQ3RFLE9BQU8sQ0FBQyxLQUFLLENBQUMsdUNBQXVDLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDaEUsQ0FBQztZQUNELFlBQVksQ0FBQyxLQUFLLENBQUMsK0JBQStCLEVBQUU7Z0JBQ2xELE9BQU8sRUFBRSxtQkFBbUIsQ0FBQyxPQUFPLENBQUM7Z0JBQ3JDLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVTtnQkFDM0IsT0FBTyxFQUFFLFlBQVksRUFBRSxPQUFPO2FBQy9CLENBQUMsQ0FBQztZQUNILElBQ0UsT0FBTyxLQUFLLG1CQUFtQixDQUFDLFFBQVE7Z0JBQ3hDLE9BQU8sS0FBSyxtQkFBbUIsQ0FBQyxRQUFRLEVBQ3hDLENBQUM7Z0JBQ0QsMkRBQTJEO2dCQUMzRCxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7Z0JBRWxCLHlDQUF5QztnQkFDekMsSUFBSSxPQUFPLEtBQUssbUJBQW1CLENBQUMsUUFBUSxFQUFFLENBQUM7b0JBQzdDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDOUIsQ0FBQztnQkFFRCw2QkFBNkI7Z0JBQzdCLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUMvQixPQUFPO1lBQ1QsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDLENBQUM7Q0FDSCJ9