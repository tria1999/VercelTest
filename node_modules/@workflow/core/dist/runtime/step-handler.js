import { waitUntil } from '@vercel/functions';
import { FatalError, RetryableError, WorkflowAPIError, WorkflowRuntimeError, } from '@workflow/errors';
import { pluralize } from '@workflow/utils';
import { getPort } from '@workflow/utils/get-port';
import { StepInvokePayloadSchema } from '@workflow/world';
import { runtimeLogger } from '../logger.js';
import { getStepFunction } from '../private.js';
import { dehydrateStepReturnValue, hydrateStepArguments, } from '../serialization.js';
import { contextStorage } from '../step/context-storage.js';
import * as Attribute from '../telemetry/semantic-conventions.js';
import { getSpanKind, linkToCurrentContext, serializeTraceCarrier, trace, withTraceContext, } from '../telemetry.js';
import { getErrorName, getErrorStack } from '../types.js';
import { getQueueOverhead, handleHealthCheckMessage, parseHealthCheckPayload, queueMessage, withHealthCheck, } from './helpers.js';
import { getWorld, getWorldHandlers } from './world.js';
const DEFAULT_STEP_MAX_RETRIES = 3;
const stepHandler = getWorldHandlers().createQueueHandler('__wkf_step_', async (message_, metadata) => {
    // Check if this is a health check message
    // NOTE: Health check messages are intentionally unauthenticated for monitoring purposes.
    // They only write a simple status response to a stream and do not expose sensitive data.
    // The stream name includes a unique correlationId that must be known by the caller.
    const healthCheck = parseHealthCheckPayload(message_);
    if (healthCheck) {
        await handleHealthCheckMessage(healthCheck, 'step');
        return;
    }
    const { workflowName, workflowRunId, workflowStartedAt, stepId, traceCarrier: traceContext, requestedAt, } = StepInvokePayloadSchema.parse(message_);
    const spanLinks = await linkToCurrentContext();
    // Execute step within the propagated trace context
    return await withTraceContext(traceContext, async () => {
        // Extract the step name from the topic name
        const stepName = metadata.queueName.slice('__wkf_step_'.length);
        const world = getWorld();
        // Get the port early to avoid async operations during step execution
        const port = await getPort();
        return trace(`STEP ${stepName}`, { kind: await getSpanKind('CONSUMER'), links: spanLinks }, async (span) => {
            span?.setAttributes({
                ...Attribute.StepName(stepName),
                ...Attribute.StepAttempt(metadata.attempt),
                ...Attribute.QueueName(metadata.queueName),
                ...Attribute.QueueMessageId(metadata.messageId),
                ...getQueueOverhead({ requestedAt }),
            });
            const stepFn = getStepFunction(stepName);
            if (!stepFn) {
                throw new Error(`Step "${stepName}" not found`);
            }
            if (typeof stepFn !== 'function') {
                throw new Error(`Step "${stepName}" is not a function (got ${typeof stepFn})`);
            }
            const maxRetries = stepFn.maxRetries ?? DEFAULT_STEP_MAX_RETRIES;
            span?.setAttributes({
                ...Attribute.WorkflowName(workflowName),
                ...Attribute.WorkflowRunId(workflowRunId),
                ...Attribute.StepId(stepId),
                ...Attribute.StepMaxRetries(maxRetries),
                ...Attribute.StepTracePropagated(!!traceContext),
            });
            let step = await world.steps.get(workflowRunId, stepId);
            runtimeLogger.debug('Step execution details', {
                stepName,
                stepId: step.stepId,
                status: step.status,
                attempt: step.attempt,
            });
            span?.setAttributes({
                ...Attribute.StepStatus(step.status),
            });
            // Check if the step has a `retryAfter` timestamp that hasn't been reached yet
            const now = Date.now();
            if (step.retryAfter && step.retryAfter.getTime() > now) {
                const timeoutSeconds = Math.ceil((step.retryAfter.getTime() - now) / 1000);
                span?.setAttributes({
                    ...Attribute.StepRetryTimeoutSeconds(timeoutSeconds),
                });
                runtimeLogger.debug('Step retryAfter timestamp not yet reached', {
                    stepName,
                    stepId: step.stepId,
                    retryAfter: step.retryAfter,
                    timeoutSeconds,
                });
                return { timeoutSeconds };
            }
            let result;
            const attempt = step.attempt + 1;
            // Check max retries FIRST before any state changes.
            // This handles edge cases where the step handler is invoked after max retries have been exceeded
            // (e.g., when the step repeatedly times out or fails before reaching the catch handler at line 822).
            // Without this check, the step would retry forever.
            // Note: maxRetries is the number of RETRIES after the first attempt, so total attempts = maxRetries + 1
            // Use > here (not >=) because this guards against re-invocation AFTER all attempts are used.
            // The post-failure check uses >= to decide whether to retry after a failure.
            if (attempt > maxRetries + 1) {
                const retryCount = attempt - 1;
                const errorMessage = `Step "${stepName}" exceeded max retries (${retryCount} ${pluralize('retry', 'retries', retryCount)})`;
                console.error(`[Workflows] "${workflowRunId}" - ${errorMessage}`);
                // Update step status first (idempotent), then create event
                await world.steps.update(workflowRunId, stepId, {
                    status: 'failed',
                    error: {
                        message: errorMessage,
                        stack: undefined,
                    },
                });
                await world.events.create(workflowRunId, {
                    eventType: 'step_failed',
                    correlationId: stepId,
                    eventData: {
                        error: errorMessage,
                        stack: step.error?.stack,
                        fatal: true,
                    },
                });
                span?.setAttributes({
                    ...Attribute.StepStatus('failed'),
                    ...Attribute.StepRetryExhausted(true),
                });
                // Re-invoke the workflow to handle the failed step
                await queueMessage(world, `__wkf_workflow_${workflowName}`, {
                    runId: workflowRunId,
                    traceCarrier: await serializeTraceCarrier(),
                    requestedAt: new Date(),
                });
                return;
            }
            try {
                if (!['pending', 'running'].includes(step.status)) {
                    // We should only be running the step if it's either
                    // a) pending - initial state, or state set on re-try
                    // b) running - if a step fails mid-execution, like a function timeout
                    // otherwise, the step has been invoked erroneously
                    console.error(`[Workflows] "${workflowRunId}" - Step invoked erroneously, expected status "pending" or "running", got "${step.status}" instead, skipping execution`);
                    span?.setAttributes({
                        ...Attribute.StepSkipped(true),
                        ...Attribute.StepSkipReason(step.status),
                    });
                    // There's a chance that a step terminates correctly, but the underlying process
                    // fails or gets killed before the stepEntrypoint has a chance to re-enqueue the run.
                    // The queue lease expires and stepEntrypoint again, which leads us here, so
                    // we optimistically re-enqueue the workflow if the step is in a terminal state,
                    // under the assumption that this edge case happened.
                    // Until we move to atomic entity/event updates (World V2), there _could_ be an edge case
                    // where the we execute this code based on the `step` entity status, but the runtime
                    // failed to create the `step_completed` event (due to failing between step and event update),
                    // in which case, this might lead to an infinite loop.
                    // https://vercel.slack.com/archives/C09125LC4AX/p1765313809066679
                    const isTerminalStep = [
                        'completed',
                        'failed',
                        'cancelled',
                    ].includes(step.status);
                    if (isTerminalStep) {
                        await queueMessage(world, `__wkf_workflow_${workflowName}`, {
                            runId: workflowRunId,
                            traceCarrier: await serializeTraceCarrier(),
                            requestedAt: new Date(),
                        });
                    }
                    return;
                }
                await world.events.create(workflowRunId, {
                    eventType: 'step_started', // TODO: Replace with 'step_retrying'
                    correlationId: stepId,
                });
                step = await world.steps.update(workflowRunId, stepId, {
                    attempt,
                    status: 'running',
                });
                if (!step.startedAt) {
                    throw new WorkflowRuntimeError(`Step "${stepId}" has no "startedAt" timestamp`);
                }
                // Hydrate the step input arguments, closure variables, and thisVal
                const ops = [];
                const hydratedInput = hydrateStepArguments(step.input, ops, workflowRunId);
                const args = hydratedInput.args;
                const thisVal = hydratedInput.thisVal ?? null;
                span?.setAttributes({
                    ...Attribute.StepArgumentsCount(args.length),
                });
                result = await contextStorage.run({
                    stepMetadata: {
                        stepId,
                        stepStartedAt: new Date(+step.startedAt),
                        attempt,
                    },
                    workflowMetadata: {
                        workflowRunId,
                        workflowStartedAt: new Date(+workflowStartedAt),
                        // TODO: there should be a getUrl method on the world interface itself. This
                        // solution only works for vercel + local worlds.
                        url: process.env.VERCEL_URL
                            ? `https://${process.env.VERCEL_URL}`
                            : `http://localhost:${port ?? 3000}`,
                    },
                    ops,
                    closureVars: hydratedInput.closureVars,
                }, () => stepFn.apply(thisVal, args));
                // NOTE: None of the code from this point is guaranteed to run
                // Since the step might fail or cause a function timeout and the process might be SIGKILL'd
                // The workflow runtime must be resilient to the below code not executing on a failed step
                result = dehydrateStepReturnValue(result, ops, workflowRunId);
                waitUntil(Promise.all(ops).catch((err) => {
                    // Ignore expected client disconnect errors (e.g., browser refresh during streaming)
                    const isAbortError = err?.name === 'AbortError' || err?.name === 'ResponseAborted';
                    if (!isAbortError)
                        throw err;
                }));
                // Mark the step as completed first. This order is important. If a concurrent
                // execution marked the step as complete, this request should throw, and
                // this prevent the step_completed event in the event log
                // TODO: this should really be atomic and handled by the world
                await world.steps.update(workflowRunId, stepId, {
                    status: 'completed',
                    output: result,
                });
                // Then, append the event log with the step result
                await world.events.create(workflowRunId, {
                    eventType: 'step_completed',
                    correlationId: stepId,
                    eventData: {
                        result: result,
                    },
                });
                span?.setAttributes({
                    ...Attribute.StepStatus('completed'),
                    ...Attribute.StepResultType(typeof result),
                });
            }
            catch (err) {
                span?.setAttributes({
                    ...Attribute.StepErrorName(getErrorName(err)),
                    ...Attribute.StepErrorMessage(String(err)),
                });
                if (WorkflowAPIError.is(err)) {
                    if (err.status === 410) {
                        // Workflow has already completed, so no-op
                        console.warn(`Workflow run "${workflowRunId}" has already completed, skipping step "${stepId}": ${err.message}`);
                        return;
                    }
                }
                if (FatalError.is(err)) {
                    const errorStack = getErrorStack(err);
                    const stackLines = errorStack.split('\n').slice(0, 4);
                    console.error(`[Workflows] "${workflowRunId}" - Encountered \`FatalError\` while executing step "${stepName}":\n  > ${stackLines.join('\n    > ')}\n\nBubbling up error to parent workflow`);
                    // Fatal error - store the error in the event log and re-invoke the workflow
                    await world.events.create(workflowRunId, {
                        eventType: 'step_failed',
                        correlationId: stepId,
                        eventData: {
                            error: String(err),
                            stack: errorStack,
                            fatal: true,
                        },
                    });
                    await world.steps.update(workflowRunId, stepId, {
                        status: 'failed',
                        error: {
                            message: err.message || String(err),
                            stack: errorStack,
                            // TODO: include error codes when we define them
                        },
                    });
                    span?.setAttributes({
                        ...Attribute.StepStatus('failed'),
                        ...Attribute.StepFatalError(true),
                    });
                }
                else {
                    const maxRetries = stepFn.maxRetries ?? DEFAULT_STEP_MAX_RETRIES;
                    span?.setAttributes({
                        ...Attribute.StepAttempt(attempt),
                        ...Attribute.StepMaxRetries(maxRetries),
                    });
                    // Note: maxRetries is the number of RETRIES after the first attempt, so total attempts = maxRetries + 1
                    if (attempt >= maxRetries + 1) {
                        // Max retries reached
                        const errorStack = getErrorStack(err);
                        const stackLines = errorStack.split('\n').slice(0, 4);
                        const retryCount = attempt - 1;
                        console.error(`[Workflows] "${workflowRunId}" - Encountered \`Error\` while executing step "${stepName}" (attempt ${attempt}, ${retryCount} ${pluralize('retry', 'retries', retryCount)}):\n  > ${stackLines.join('\n    > ')}\n\n  Max retries reached\n  Bubbling error to parent workflow`);
                        const errorMessage = `Step "${stepName}" failed after ${maxRetries} ${pluralize('retry', 'retries', maxRetries)}: ${String(err)}`;
                        await world.events.create(workflowRunId, {
                            eventType: 'step_failed',
                            correlationId: stepId,
                            eventData: {
                                error: errorMessage,
                                stack: errorStack,
                                fatal: true,
                            },
                        });
                        await world.steps.update(workflowRunId, stepId, {
                            status: 'failed',
                            error: {
                                message: errorMessage,
                                stack: errorStack,
                            },
                        });
                        span?.setAttributes({
                            ...Attribute.StepStatus('failed'),
                            ...Attribute.StepRetryExhausted(true),
                        });
                    }
                    else {
                        // Not at max retries yet - log as a retryable error
                        if (RetryableError.is(err)) {
                            console.warn(`[Workflows] "${workflowRunId}" - Encountered \`RetryableError\` while executing step "${stepName}" (attempt ${attempt}):\n  > ${String(err.message)}\n\n  This step has failed but will be retried`);
                        }
                        else {
                            const stackLines = getErrorStack(err).split('\n').slice(0, 4);
                            console.error(`[Workflows] "${workflowRunId}" - Encountered \`Error\` while executing step "${stepName}" (attempt ${attempt}):\n  > ${stackLines.join('\n    > ')}\n\n  This step has failed but will be retried`);
                        }
                        await world.events.create(workflowRunId, {
                            eventType: 'step_failed',
                            correlationId: stepId,
                            eventData: {
                                error: String(err),
                                stack: getErrorStack(err),
                            },
                        });
                        await world.steps.update(workflowRunId, stepId, {
                            status: 'pending', // TODO: Should be "retrying" once we have that status
                            ...(RetryableError.is(err) && {
                                retryAfter: err.retryAfter,
                            }),
                        });
                        const timeoutSeconds = Math.max(1, RetryableError.is(err)
                            ? Math.ceil((+err.retryAfter.getTime() - Date.now()) / 1000)
                            : 1);
                        span?.setAttributes({
                            ...Attribute.StepRetryTimeoutSeconds(timeoutSeconds),
                            ...Attribute.StepRetryWillRetry(true),
                        });
                        // It's a retryable error - so have the queue keep the message visible
                        // so that it gets retried.
                        return { timeoutSeconds };
                    }
                }
            }
            await queueMessage(world, `__wkf_workflow_${workflowName}`, {
                runId: workflowRunId,
                traceCarrier: await serializeTraceCarrier(),
                requestedAt: new Date(),
            });
        });
    });
});
/**
 * A single route that handles any step execution request and routes to the
 * appropriate step function. We may eventually want to create different bundles
 * for each step, this is temporary.
 */
export const stepEntrypoint = 
/* @__PURE__ */ withHealthCheck(stepHandler);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcC1oYW5kbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3J1bnRpbWUvc3RlcC1oYW5kbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUM5QyxPQUFPLEVBQ0wsVUFBVSxFQUNWLGNBQWMsRUFDZCxnQkFBZ0IsRUFDaEIsb0JBQW9CLEdBQ3JCLE1BQU0sa0JBQWtCLENBQUM7QUFDMUIsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzVDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUNuRCxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBQzdDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFaEQsT0FBTyxFQUNMLHdCQUF3QixFQUN4QixvQkFBb0IsR0FDckIsTUFBTSxxQkFBcUIsQ0FBQztBQUM3QixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDNUQsT0FBTyxLQUFLLFNBQVMsTUFBTSxzQ0FBc0MsQ0FBQztBQUNsRSxPQUFPLEVBQ0wsV0FBVyxFQUNYLG9CQUFvQixFQUNwQixxQkFBcUIsRUFDckIsS0FBSyxFQUNMLGdCQUFnQixHQUNqQixNQUFNLGlCQUFpQixDQUFDO0FBQ3pCLE9BQU8sRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQzFELE9BQU8sRUFDTCxnQkFBZ0IsRUFDaEIsd0JBQXdCLEVBQ3hCLHVCQUF1QixFQUN2QixZQUFZLEVBQ1osZUFBZSxHQUNoQixNQUFNLGNBQWMsQ0FBQztBQUN0QixPQUFPLEVBQUUsUUFBUSxFQUFFLGdCQUFnQixFQUFFLE1BQU0sWUFBWSxDQUFDO0FBRXhELE1BQU0sd0JBQXdCLEdBQUcsQ0FBQyxDQUFDO0FBRW5DLE1BQU0sV0FBVyxHQUFHLGdCQUFnQixFQUFFLENBQUMsa0JBQWtCLENBQ3ZELGFBQWEsRUFDYixLQUFLLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxFQUFFO0lBQzNCLDBDQUEwQztJQUMxQyx5RkFBeUY7SUFDekYseUZBQXlGO0lBQ3pGLG9GQUFvRjtJQUNwRixNQUFNLFdBQVcsR0FBRyx1QkFBdUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN0RCxJQUFJLFdBQVcsRUFBRSxDQUFDO1FBQ2hCLE1BQU0sd0JBQXdCLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3BELE9BQU87SUFDVCxDQUFDO0lBRUQsTUFBTSxFQUNKLFlBQVksRUFDWixhQUFhLEVBQ2IsaUJBQWlCLEVBQ2pCLE1BQU0sRUFDTixZQUFZLEVBQUUsWUFBWSxFQUMxQixXQUFXLEdBQ1osR0FBRyx1QkFBdUIsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDNUMsTUFBTSxTQUFTLEdBQUcsTUFBTSxvQkFBb0IsRUFBRSxDQUFDO0lBQy9DLG1EQUFtRDtJQUNuRCxPQUFPLE1BQU0sZ0JBQWdCLENBQUMsWUFBWSxFQUFFLEtBQUssSUFBSSxFQUFFO1FBQ3JELDRDQUE0QztRQUM1QyxNQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDaEUsTUFBTSxLQUFLLEdBQUcsUUFBUSxFQUFFLENBQUM7UUFFekIscUVBQXFFO1FBQ3JFLE1BQU0sSUFBSSxHQUFHLE1BQU0sT0FBTyxFQUFFLENBQUM7UUFFN0IsT0FBTyxLQUFLLENBQ1YsUUFBUSxRQUFRLEVBQUUsRUFDbEIsRUFBRSxJQUFJLEVBQUUsTUFBTSxXQUFXLENBQUMsVUFBVSxDQUFDLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxFQUN6RCxLQUFLLEVBQUUsSUFBSSxFQUFFLEVBQUU7WUFDYixJQUFJLEVBQUUsYUFBYSxDQUFDO2dCQUNsQixHQUFHLFNBQVMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDO2dCQUMvQixHQUFHLFNBQVMsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztnQkFDMUMsR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUM7Z0JBQzFDLEdBQUcsU0FBUyxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDO2dCQUMvQyxHQUFHLGdCQUFnQixDQUFDLEVBQUUsV0FBVyxFQUFFLENBQUM7YUFDckMsQ0FBQyxDQUFDO1lBRUgsTUFBTSxNQUFNLEdBQUcsZUFBZSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3pDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDWixNQUFNLElBQUksS0FBSyxDQUFDLFNBQVMsUUFBUSxhQUFhLENBQUMsQ0FBQztZQUNsRCxDQUFDO1lBQ0QsSUFBSSxPQUFPLE1BQU0sS0FBSyxVQUFVLEVBQUUsQ0FBQztnQkFDakMsTUFBTSxJQUFJLEtBQUssQ0FDYixTQUFTLFFBQVEsNEJBQTRCLE9BQU8sTUFBTSxHQUFHLENBQzlELENBQUM7WUFDSixDQUFDO1lBRUQsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLFVBQVUsSUFBSSx3QkFBd0IsQ0FBQztZQUVqRSxJQUFJLEVBQUUsYUFBYSxDQUFDO2dCQUNsQixHQUFHLFNBQVMsQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDO2dCQUN2QyxHQUFHLFNBQVMsQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDO2dCQUN6QyxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO2dCQUMzQixHQUFHLFNBQVMsQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDO2dCQUN2QyxHQUFHLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDO2FBQ2pELENBQUMsQ0FBQztZQUVILElBQUksSUFBSSxHQUFHLE1BQU0sS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBRXhELGFBQWEsQ0FBQyxLQUFLLENBQUMsd0JBQXdCLEVBQUU7Z0JBQzVDLFFBQVE7Z0JBQ1IsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO2dCQUNuQixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07Z0JBQ25CLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTzthQUN0QixDQUFDLENBQUM7WUFFSCxJQUFJLEVBQUUsYUFBYSxDQUFDO2dCQUNsQixHQUFHLFNBQVMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQzthQUNyQyxDQUFDLENBQUM7WUFFSCw4RUFBOEU7WUFDOUUsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ3ZCLElBQUksSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxHQUFHLEdBQUcsRUFBRSxDQUFDO2dCQUN2RCxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUM5QixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLEdBQUcsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUN6QyxDQUFDO2dCQUNGLElBQUksRUFBRSxhQUFhLENBQUM7b0JBQ2xCLEdBQUcsU0FBUyxDQUFDLHVCQUF1QixDQUFDLGNBQWMsQ0FBQztpQkFDckQsQ0FBQyxDQUFDO2dCQUNILGFBQWEsQ0FBQyxLQUFLLENBQUMsMkNBQTJDLEVBQUU7b0JBQy9ELFFBQVE7b0JBQ1IsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO29CQUNuQixVQUFVLEVBQUUsSUFBSSxDQUFDLFVBQVU7b0JBQzNCLGNBQWM7aUJBQ2YsQ0FBQyxDQUFDO2dCQUNILE9BQU8sRUFBRSxjQUFjLEVBQUUsQ0FBQztZQUM1QixDQUFDO1lBRUQsSUFBSSxNQUFlLENBQUM7WUFDcEIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7WUFFakMsb0RBQW9EO1lBQ3BELGlHQUFpRztZQUNqRyxxR0FBcUc7WUFDckcsb0RBQW9EO1lBQ3BELHdHQUF3RztZQUN4Ryw2RkFBNkY7WUFDN0YsNkVBQTZFO1lBQzdFLElBQUksT0FBTyxHQUFHLFVBQVUsR0FBRyxDQUFDLEVBQUUsQ0FBQztnQkFDN0IsTUFBTSxVQUFVLEdBQUcsT0FBTyxHQUFHLENBQUMsQ0FBQztnQkFDL0IsTUFBTSxZQUFZLEdBQUcsU0FBUyxRQUFRLDJCQUEyQixVQUFVLElBQUksU0FBUyxDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQztnQkFDNUgsT0FBTyxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsYUFBYSxPQUFPLFlBQVksRUFBRSxDQUFDLENBQUM7Z0JBQ2xFLDJEQUEyRDtnQkFDM0QsTUFBTSxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxhQUFhLEVBQUUsTUFBTSxFQUFFO29CQUM5QyxNQUFNLEVBQUUsUUFBUTtvQkFDaEIsS0FBSyxFQUFFO3dCQUNMLE9BQU8sRUFBRSxZQUFZO3dCQUNyQixLQUFLLEVBQUUsU0FBUztxQkFDakI7aUJBQ0YsQ0FBQyxDQUFDO2dCQUNILE1BQU0sS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFO29CQUN2QyxTQUFTLEVBQUUsYUFBYTtvQkFDeEIsYUFBYSxFQUFFLE1BQU07b0JBQ3JCLFNBQVMsRUFBRTt3QkFDVCxLQUFLLEVBQUUsWUFBWTt3QkFDbkIsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSzt3QkFDeEIsS0FBSyxFQUFFLElBQUk7cUJBQ1o7aUJBQ0YsQ0FBQyxDQUFDO2dCQUVILElBQUksRUFBRSxhQUFhLENBQUM7b0JBQ2xCLEdBQUcsU0FBUyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUM7b0JBQ2pDLEdBQUcsU0FBUyxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQztpQkFDdEMsQ0FBQyxDQUFDO2dCQUVILG1EQUFtRDtnQkFDbkQsTUFBTSxZQUFZLENBQUMsS0FBSyxFQUFFLGtCQUFrQixZQUFZLEVBQUUsRUFBRTtvQkFDMUQsS0FBSyxFQUFFLGFBQWE7b0JBQ3BCLFlBQVksRUFBRSxNQUFNLHFCQUFxQixFQUFFO29CQUMzQyxXQUFXLEVBQUUsSUFBSSxJQUFJLEVBQUU7aUJBQ3hCLENBQUMsQ0FBQztnQkFDSCxPQUFPO1lBQ1QsQ0FBQztZQUVELElBQUksQ0FBQztnQkFDSCxJQUFJLENBQUMsQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO29CQUNsRCxvREFBb0Q7b0JBQ3BELHFEQUFxRDtvQkFDckQsc0VBQXNFO29CQUN0RSxtREFBbUQ7b0JBQ25ELE9BQU8sQ0FBQyxLQUFLLENBQ1gsZ0JBQWdCLGFBQWEsOEVBQThFLElBQUksQ0FBQyxNQUFNLCtCQUErQixDQUN0SixDQUFDO29CQUNGLElBQUksRUFBRSxhQUFhLENBQUM7d0JBQ2xCLEdBQUcsU0FBUyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7d0JBQzlCLEdBQUcsU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO3FCQUN6QyxDQUFDLENBQUM7b0JBQ0gsZ0ZBQWdGO29CQUNoRixxRkFBcUY7b0JBQ3JGLDRFQUE0RTtvQkFDNUUsZ0ZBQWdGO29CQUNoRixxREFBcUQ7b0JBQ3JELHlGQUF5RjtvQkFDekYsb0ZBQW9GO29CQUNwRiw4RkFBOEY7b0JBQzlGLHNEQUFzRDtvQkFDdEQsa0VBQWtFO29CQUNsRSxNQUFNLGNBQWMsR0FBRzt3QkFDckIsV0FBVzt3QkFDWCxRQUFRO3dCQUNSLFdBQVc7cUJBQ1osQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUN4QixJQUFJLGNBQWMsRUFBRSxDQUFDO3dCQUNuQixNQUFNLFlBQVksQ0FBQyxLQUFLLEVBQUUsa0JBQWtCLFlBQVksRUFBRSxFQUFFOzRCQUMxRCxLQUFLLEVBQUUsYUFBYTs0QkFDcEIsWUFBWSxFQUFFLE1BQU0scUJBQXFCLEVBQUU7NEJBQzNDLFdBQVcsRUFBRSxJQUFJLElBQUksRUFBRTt5QkFDeEIsQ0FBQyxDQUFDO29CQUNMLENBQUM7b0JBQ0QsT0FBTztnQkFDVCxDQUFDO2dCQUVELE1BQU0sS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFO29CQUN2QyxTQUFTLEVBQUUsY0FBYyxFQUFFLHFDQUFxQztvQkFDaEUsYUFBYSxFQUFFLE1BQU07aUJBQ3RCLENBQUMsQ0FBQztnQkFFSCxJQUFJLEdBQUcsTUFBTSxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxhQUFhLEVBQUUsTUFBTSxFQUFFO29CQUNyRCxPQUFPO29CQUNQLE1BQU0sRUFBRSxTQUFTO2lCQUNsQixDQUFDLENBQUM7Z0JBRUgsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztvQkFDcEIsTUFBTSxJQUFJLG9CQUFvQixDQUM1QixTQUFTLE1BQU0sZ0NBQWdDLENBQ2hELENBQUM7Z0JBQ0osQ0FBQztnQkFDRCxtRUFBbUU7Z0JBQ25FLE1BQU0sR0FBRyxHQUFvQixFQUFFLENBQUM7Z0JBQ2hDLE1BQU0sYUFBYSxHQUFHLG9CQUFvQixDQUN4QyxJQUFJLENBQUMsS0FBSyxFQUNWLEdBQUcsRUFDSCxhQUFhLENBQ2QsQ0FBQztnQkFFRixNQUFNLElBQUksR0FBRyxhQUFhLENBQUMsSUFBSSxDQUFDO2dCQUNoQyxNQUFNLE9BQU8sR0FBRyxhQUFhLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQztnQkFFOUMsSUFBSSxFQUFFLGFBQWEsQ0FBQztvQkFDbEIsR0FBRyxTQUFTLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztpQkFDN0MsQ0FBQyxDQUFDO2dCQUVILE1BQU0sR0FBRyxNQUFNLGNBQWMsQ0FBQyxHQUFHLENBQy9CO29CQUNFLFlBQVksRUFBRTt3QkFDWixNQUFNO3dCQUNOLGFBQWEsRUFBRSxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7d0JBQ3hDLE9BQU87cUJBQ1I7b0JBQ0QsZ0JBQWdCLEVBQUU7d0JBQ2hCLGFBQWE7d0JBQ2IsaUJBQWlCLEVBQUUsSUFBSSxJQUFJLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQzt3QkFDL0MsNEVBQTRFO3dCQUM1RSxpREFBaUQ7d0JBQ2pELEdBQUcsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLFVBQVU7NEJBQ3pCLENBQUMsQ0FBQyxXQUFXLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFOzRCQUNyQyxDQUFDLENBQUMsb0JBQW9CLElBQUksSUFBSSxJQUFJLEVBQUU7cUJBQ3ZDO29CQUNELEdBQUc7b0JBQ0gsV0FBVyxFQUFFLGFBQWEsQ0FBQyxXQUFXO2lCQUN2QyxFQUNELEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUNsQyxDQUFDO2dCQUVGLDhEQUE4RDtnQkFDOUQsMkZBQTJGO2dCQUMzRiwwRkFBMEY7Z0JBQzFGLE1BQU0sR0FBRyx3QkFBd0IsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLGFBQWEsQ0FBQyxDQUFDO2dCQUU5RCxTQUFTLENBQ1AsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtvQkFDN0Isb0ZBQW9GO29CQUNwRixNQUFNLFlBQVksR0FDaEIsR0FBRyxFQUFFLElBQUksS0FBSyxZQUFZLElBQUksR0FBRyxFQUFFLElBQUksS0FBSyxpQkFBaUIsQ0FBQztvQkFDaEUsSUFBSSxDQUFDLFlBQVk7d0JBQUUsTUFBTSxHQUFHLENBQUM7Z0JBQy9CLENBQUMsQ0FBQyxDQUNILENBQUM7Z0JBRUYsNkVBQTZFO2dCQUM3RSx3RUFBd0U7Z0JBQ3hFLHlEQUF5RDtnQkFDekQsOERBQThEO2dCQUM5RCxNQUFNLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRSxNQUFNLEVBQUU7b0JBQzlDLE1BQU0sRUFBRSxXQUFXO29CQUNuQixNQUFNLEVBQUUsTUFBc0I7aUJBQy9CLENBQUMsQ0FBQztnQkFFSCxrREFBa0Q7Z0JBQ2xELE1BQU0sS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFO29CQUN2QyxTQUFTLEVBQUUsZ0JBQWdCO29CQUMzQixhQUFhLEVBQUUsTUFBTTtvQkFDckIsU0FBUyxFQUFFO3dCQUNULE1BQU0sRUFBRSxNQUFzQjtxQkFDL0I7aUJBQ0YsQ0FBQyxDQUFDO2dCQUVILElBQUksRUFBRSxhQUFhLENBQUM7b0JBQ2xCLEdBQUcsU0FBUyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUM7b0JBQ3BDLEdBQUcsU0FBUyxDQUFDLGNBQWMsQ0FBQyxPQUFPLE1BQU0sQ0FBQztpQkFDM0MsQ0FBQyxDQUFDO1lBQ0wsQ0FBQztZQUFDLE9BQU8sR0FBWSxFQUFFLENBQUM7Z0JBQ3RCLElBQUksRUFBRSxhQUFhLENBQUM7b0JBQ2xCLEdBQUcsU0FBUyxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQzdDLEdBQUcsU0FBUyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztpQkFDM0MsQ0FBQyxDQUFDO2dCQUVILElBQUksZ0JBQWdCLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7b0JBQzdCLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQzt3QkFDdkIsMkNBQTJDO3dCQUMzQyxPQUFPLENBQUMsSUFBSSxDQUNWLGlCQUFpQixhQUFhLDJDQUEyQyxNQUFNLE1BQU0sR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUNuRyxDQUFDO3dCQUNGLE9BQU87b0JBQ1QsQ0FBQztnQkFDSCxDQUFDO2dCQUVELElBQUksVUFBVSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO29CQUN2QixNQUFNLFVBQVUsR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ3RDLE1BQU0sVUFBVSxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFDdEQsT0FBTyxDQUFDLEtBQUssQ0FDWCxnQkFBZ0IsYUFBYSx3REFBd0QsUUFBUSxXQUFXLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLDBDQUEwQyxDQUM5SyxDQUFDO29CQUNGLDRFQUE0RTtvQkFDNUUsTUFBTSxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLEVBQUU7d0JBQ3ZDLFNBQVMsRUFBRSxhQUFhO3dCQUN4QixhQUFhLEVBQUUsTUFBTTt3QkFDckIsU0FBUyxFQUFFOzRCQUNULEtBQUssRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDOzRCQUNsQixLQUFLLEVBQUUsVUFBVTs0QkFDakIsS0FBSyxFQUFFLElBQUk7eUJBQ1o7cUJBQ0YsQ0FBQyxDQUFDO29CQUNILE1BQU0sS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFLE1BQU0sRUFBRTt3QkFDOUMsTUFBTSxFQUFFLFFBQVE7d0JBQ2hCLEtBQUssRUFBRTs0QkFDTCxPQUFPLEVBQUUsR0FBRyxDQUFDLE9BQU8sSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDOzRCQUNuQyxLQUFLLEVBQUUsVUFBVTs0QkFDakIsZ0RBQWdEO3lCQUNqRDtxQkFDRixDQUFDLENBQUM7b0JBRUgsSUFBSSxFQUFFLGFBQWEsQ0FBQzt3QkFDbEIsR0FBRyxTQUFTLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQzt3QkFDakMsR0FBRyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQztxQkFDbEMsQ0FBQyxDQUFDO2dCQUNMLENBQUM7cUJBQU0sQ0FBQztvQkFDTixNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsVUFBVSxJQUFJLHdCQUF3QixDQUFDO29CQUVqRSxJQUFJLEVBQUUsYUFBYSxDQUFDO3dCQUNsQixHQUFHLFNBQVMsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDO3dCQUNqQyxHQUFHLFNBQVMsQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDO3FCQUN4QyxDQUFDLENBQUM7b0JBRUgsd0dBQXdHO29CQUN4RyxJQUFJLE9BQU8sSUFBSSxVQUFVLEdBQUcsQ0FBQyxFQUFFLENBQUM7d0JBQzlCLHNCQUFzQjt3QkFDdEIsTUFBTSxVQUFVLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO3dCQUN0QyxNQUFNLFVBQVUsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7d0JBQ3RELE1BQU0sVUFBVSxHQUFHLE9BQU8sR0FBRyxDQUFDLENBQUM7d0JBQy9CLE9BQU8sQ0FBQyxLQUFLLENBQ1gsZ0JBQWdCLGFBQWEsbURBQW1ELFFBQVEsY0FBYyxPQUFPLEtBQUssVUFBVSxJQUFJLFNBQVMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQVUsQ0FBQyxXQUFXLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGdFQUFnRSxDQUNoUixDQUFDO3dCQUNGLE1BQU0sWUFBWSxHQUFHLFNBQVMsUUFBUSxrQkFBa0IsVUFBVSxJQUFJLFNBQVMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQVUsQ0FBQyxLQUFLLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO3dCQUNsSSxNQUFNLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRTs0QkFDdkMsU0FBUyxFQUFFLGFBQWE7NEJBQ3hCLGFBQWEsRUFBRSxNQUFNOzRCQUNyQixTQUFTLEVBQUU7Z0NBQ1QsS0FBSyxFQUFFLFlBQVk7Z0NBQ25CLEtBQUssRUFBRSxVQUFVO2dDQUNqQixLQUFLLEVBQUUsSUFBSTs2QkFDWjt5QkFDRixDQUFDLENBQUM7d0JBQ0gsTUFBTSxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxhQUFhLEVBQUUsTUFBTSxFQUFFOzRCQUM5QyxNQUFNLEVBQUUsUUFBUTs0QkFDaEIsS0FBSyxFQUFFO2dDQUNMLE9BQU8sRUFBRSxZQUFZO2dDQUNyQixLQUFLLEVBQUUsVUFBVTs2QkFDbEI7eUJBQ0YsQ0FBQyxDQUFDO3dCQUVILElBQUksRUFBRSxhQUFhLENBQUM7NEJBQ2xCLEdBQUcsU0FBUyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUM7NEJBQ2pDLEdBQUcsU0FBUyxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQzt5QkFDdEMsQ0FBQyxDQUFDO29CQUNMLENBQUM7eUJBQU0sQ0FBQzt3QkFDTixvREFBb0Q7d0JBQ3BELElBQUksY0FBYyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDOzRCQUMzQixPQUFPLENBQUMsSUFBSSxDQUNWLGdCQUFnQixhQUFhLDREQUE0RCxRQUFRLGNBQWMsT0FBTyxXQUFXLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLGdEQUFnRCxDQUNyTSxDQUFDO3dCQUNKLENBQUM7NkJBQU0sQ0FBQzs0QkFDTixNQUFNLFVBQVUsR0FBRyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7NEJBQzlELE9BQU8sQ0FBQyxLQUFLLENBQ1gsZ0JBQWdCLGFBQWEsbURBQW1ELFFBQVEsY0FBYyxPQUFPLFdBQVcsVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsZ0RBQWdELENBQ3BNLENBQUM7d0JBQ0osQ0FBQzt3QkFDRCxNQUFNLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRTs0QkFDdkMsU0FBUyxFQUFFLGFBQWE7NEJBQ3hCLGFBQWEsRUFBRSxNQUFNOzRCQUNyQixTQUFTLEVBQUU7Z0NBQ1QsS0FBSyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUM7Z0NBQ2xCLEtBQUssRUFBRSxhQUFhLENBQUMsR0FBRyxDQUFDOzZCQUMxQjt5QkFDRixDQUFDLENBQUM7d0JBRUgsTUFBTSxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxhQUFhLEVBQUUsTUFBTSxFQUFFOzRCQUM5QyxNQUFNLEVBQUUsU0FBUyxFQUFFLHNEQUFzRDs0QkFDekUsR0FBRyxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUk7Z0NBQzVCLFVBQVUsRUFBRSxHQUFHLENBQUMsVUFBVTs2QkFDM0IsQ0FBQzt5QkFDSCxDQUFDLENBQUM7d0JBRUgsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FDN0IsQ0FBQyxFQUNELGNBQWMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDOzRCQUNwQixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUM7NEJBQzVELENBQUMsQ0FBQyxDQUFDLENBQ04sQ0FBQzt3QkFFRixJQUFJLEVBQUUsYUFBYSxDQUFDOzRCQUNsQixHQUFHLFNBQVMsQ0FBQyx1QkFBdUIsQ0FBQyxjQUFjLENBQUM7NEJBQ3BELEdBQUcsU0FBUyxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQzt5QkFDdEMsQ0FBQyxDQUFDO3dCQUVILHNFQUFzRTt3QkFDdEUsMkJBQTJCO3dCQUMzQixPQUFPLEVBQUUsY0FBYyxFQUFFLENBQUM7b0JBQzVCLENBQUM7Z0JBQ0gsQ0FBQztZQUNILENBQUM7WUFFRCxNQUFNLFlBQVksQ0FBQyxLQUFLLEVBQUUsa0JBQWtCLFlBQVksRUFBRSxFQUFFO2dCQUMxRCxLQUFLLEVBQUUsYUFBYTtnQkFDcEIsWUFBWSxFQUFFLE1BQU0scUJBQXFCLEVBQUU7Z0JBQzNDLFdBQVcsRUFBRSxJQUFJLElBQUksRUFBRTthQUN4QixDQUFDLENBQUM7UUFDTCxDQUFDLENBQ0YsQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUNGLENBQUM7QUFFRjs7OztHQUlHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sY0FBYztBQUN6QixlQUFlLENBQUMsZUFBZSxDQUFDLFdBQVcsQ0FBQyxDQUFDIn0=