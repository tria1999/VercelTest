import { WorkflowAPIError } from '@workflow/errors';
import { dehydrateStepArguments } from '../serialization.js';
import * as Attribute from '../telemetry/semantic-conventions.js';
import { serializeTraceCarrier } from '../telemetry.js';
import { queueMessage } from './helpers.js';
/**
 * Processes a single hook by creating it in the database and event log.
 */
async function processHook({ queueItem, world, runId, global, }) {
    try {
        // Create hook in database
        const hookMetadata = typeof queueItem.metadata === 'undefined'
            ? undefined
            : dehydrateStepArguments(queueItem.metadata, global);
        await world.hooks.create(runId, {
            hookId: queueItem.correlationId,
            token: queueItem.token,
            metadata: hookMetadata,
        });
        // Create hook_created event in event log
        await world.events.create(runId, {
            eventType: 'hook_created',
            correlationId: queueItem.correlationId,
        });
    }
    catch (err) {
        if (WorkflowAPIError.is(err)) {
            if (err.status === 409) {
                // Hook already exists (duplicate hook_id constraint), so we can skip it
                console.warn(`Hook with correlation ID "${queueItem.correlationId}" already exists, skipping: ${err.message}`);
                return;
            }
            else if (err.status === 410) {
                // Workflow has already completed, so no-op
                console.warn(`Workflow run "${runId}" has already completed, skipping hook "${queueItem.correlationId}": ${err.message}`);
                return;
            }
        }
        throw err;
    }
}
/**
 * Processes a single step by creating it in the database and queueing execution.
 *
 * IMPORTANT: The queue write MUST always happen, even if the step already exists.
 * This handles the case where:
 *   1. Step is written to workflow database
 *   2. Process crashes, times out, or fails before queue write completes
 *   3. Upstream retry occurs
 *   4. Step already exists in database (409 conflict)
 *
 * If we skipped the queue write on 409, the step would sit "pending" forever
 * with 0 attempts. The queue write uses an idempotency key (correlation ID),
 * so duplicate queue writes are safely deduplicated by the queue service.
 */
async function processStep({ queueItem, world, runId, workflowName, workflowStartedAt, global, }) {
    const dehydratedInput = dehydrateStepArguments({
        args: queueItem.args,
        closureVars: queueItem.closureVars,
        thisVal: queueItem.thisVal,
    }, global);
    // The stepId to use for the queue message. This will be the correlation ID
    // regardless of whether we created a new step or the step already existed.
    const stepId = queueItem.correlationId;
    try {
        await world.steps.create(runId, {
            stepId: queueItem.correlationId,
            stepName: queueItem.stepName,
            input: dehydratedInput,
        });
    }
    catch (err) {
        if (WorkflowAPIError.is(err) && err.status === 409) {
            // Step already exists - this is expected on retries. We still need to
            // proceed with the queue write below to ensure the step gets executed.
            // See function comment above for details on why this is critical.
            console.warn(`Step "${queueItem.stepName}" with correlation ID "${queueItem.correlationId}" already exists, proceeding with queue write`);
        }
        else {
            throw err;
        }
    }
    // Always write to queue, even if step already existed. The idempotency key
    // ensures duplicate queue writes are safely deduplicated by the queue service.
    await queueMessage(world, `__wkf_step_${queueItem.stepName}`, {
        workflowName,
        workflowRunId: runId,
        workflowStartedAt,
        stepId,
        traceCarrier: await serializeTraceCarrier(),
        requestedAt: new Date(),
    }, {
        idempotencyKey: queueItem.correlationId,
    });
}
/**
 * Processes a single wait by creating the event and calculating timeout.
 * @returns The timeout in seconds, or null if the wait already exists.
 */
async function processWait({ queueItem, world, runId, }) {
    try {
        // Only create wait_created event if it hasn't been created yet
        if (!queueItem.hasCreatedEvent) {
            await world.events.create(runId, {
                eventType: 'wait_created',
                correlationId: queueItem.correlationId,
                eventData: {
                    resumeAt: queueItem.resumeAt,
                },
            });
        }
        // Calculate how long to wait before resuming
        const now = Date.now();
        const resumeAtMs = queueItem.resumeAt.getTime();
        const delayMs = Math.max(1000, resumeAtMs - now);
        return Math.ceil(delayMs / 1000);
    }
    catch (err) {
        if (WorkflowAPIError.is(err) && err.status === 409) {
            // Wait already exists, so we can skip it
            console.warn(`Wait with correlation ID "${queueItem.correlationId}" already exists, skipping: ${err.message}`);
            return null;
        }
        throw err;
    }
}
/**
 * Handles a workflow suspension by processing all pending operations (hooks, steps, waits).
 * Hooks are processed first to prevent race conditions, then steps and waits in parallel.
 */
export async function handleSuspension({ suspension, world, runId, workflowName, workflowStartedAt, span, }) {
    // Separate queue items by type for parallel processing
    const stepItems = suspension.steps.filter((item) => item.type === 'step');
    const hookItems = suspension.steps.filter((item) => item.type === 'hook');
    const waitItems = suspension.steps.filter((item) => item.type === 'wait');
    // Process all hooks first to prevent race conditions
    await Promise.all(hookItems.map((queueItem) => processHook({
        queueItem,
        world,
        runId,
        global: suspension.globalThis,
    })));
    // Then process steps and waits in parallel
    const [, waitTimeouts] = await Promise.all([
        Promise.all(stepItems.map((queueItem) => processStep({
            queueItem,
            world,
            runId,
            workflowName,
            workflowStartedAt,
            global: suspension.globalThis,
        }))),
        Promise.all(waitItems.map((queueItem) => processWait({
            queueItem,
            world,
            runId,
        }))),
    ]);
    // Find minimum timeout from waits
    const minTimeoutSeconds = waitTimeouts.reduce((min, timeout) => {
        if (timeout === null)
            return min;
        if (min === null)
            return timeout;
        return Math.min(min, timeout);
    }, null);
    span?.setAttributes({
        ...Attribute.WorkflowRunStatus('workflow_suspended'),
        ...Attribute.WorkflowStepsCreated(stepItems.length),
        ...Attribute.WorkflowHooksCreated(hookItems.length),
        ...Attribute.WorkflowWaitsCreated(waitItems.length),
    });
    // If we encountered any waits, return the minimum timeout
    if (minTimeoutSeconds !== null) {
        return { timeoutSeconds: minTimeoutSeconds };
    }
    return {};
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3VzcGVuc2lvbi1oYW5kbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3J1bnRpbWUvc3VzcGVuc2lvbi1oYW5kbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBU3BELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQzdELE9BQU8sS0FBSyxTQUFTLE1BQU0sc0NBQXNDLENBQUM7QUFDbEUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDeEQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGNBQWMsQ0FBQztBQXNCNUM7O0dBRUc7QUFDSCxLQUFLLFVBQVUsV0FBVyxDQUFDLEVBQ3pCLFNBQVMsRUFDVCxLQUFLLEVBQ0wsS0FBSyxFQUNMLE1BQU0sR0FDWTtJQUNsQixJQUFJLENBQUM7UUFDSCwwQkFBMEI7UUFDMUIsTUFBTSxZQUFZLEdBQ2hCLE9BQU8sU0FBUyxDQUFDLFFBQVEsS0FBSyxXQUFXO1lBQ3ZDLENBQUMsQ0FBQyxTQUFTO1lBQ1gsQ0FBQyxDQUFDLHNCQUFzQixDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDekQsTUFBTSxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUU7WUFDOUIsTUFBTSxFQUFFLFNBQVMsQ0FBQyxhQUFhO1lBQy9CLEtBQUssRUFBRSxTQUFTLENBQUMsS0FBSztZQUN0QixRQUFRLEVBQUUsWUFBWTtTQUN2QixDQUFDLENBQUM7UUFFSCx5Q0FBeUM7UUFDekMsTUFBTSxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUU7WUFDL0IsU0FBUyxFQUFFLGNBQWM7WUFDekIsYUFBYSxFQUFFLFNBQVMsQ0FBQyxhQUFhO1NBQ3ZDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFBQyxPQUFPLEdB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