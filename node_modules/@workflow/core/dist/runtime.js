import { WorkflowRunCancelledError, WorkflowRunFailedError, WorkflowRunNotCompletedError, } from '@workflow/errors';
import { WorkflowInvokePayloadSchema, } from '@workflow/world';
import { WorkflowSuspension } from './global.js';
import { runtimeLogger } from './logger.js';
import { parseWorkflowName } from './parse-name.js';
import { getAllWorkflowRunEvents, getQueueOverhead, handleHealthCheckMessage, parseHealthCheckPayload, withHealthCheck, } from './runtime/helpers.js';
import { handleSuspension } from './runtime/suspension-handler.js';
import { getWorld, getWorldHandlers } from './runtime/world.js';
import { getExternalRevivers, hydrateWorkflowReturnValue, } from './serialization.js';
import { remapErrorStack } from './source-map.js';
import * as Attribute from './telemetry/semantic-conventions.js';
import { linkToCurrentContext, trace, withTraceContext } from './telemetry.js';
import { getErrorName, getErrorStack } from './types.js';
import { buildWorkflowSuspensionMessage, getWorkflowRunStreamId, } from './util.js';
import { runWorkflow } from './workflow.js';
export { WorkflowSuspension } from './global.js';
export { healthCheck, } from './runtime/helpers.js';
export { getHookByToken, resumeHook, resumeWebhook, } from './runtime/resume-hook.js';
export { start } from './runtime/start.js';
export { stepEntrypoint } from './runtime/step-handler.js';
export { createWorld, getWorld, getWorldHandlers, setWorld, } from './runtime/world.js';
/**
 * A handler class for a workflow run.
 */
export class Run {
    /**
     * The ID of the workflow run.
     */
    runId;
    /**
     * The world object.
     * @internal
     */
    world;
    constructor(runId) {
        this.runId = runId;
        this.world = getWorld();
    }
    /**
     * Cancels the workflow run.
     */
    async cancel() {
        await this.world.runs.cancel(this.runId);
    }
    /**
     * The status of the workflow run.
     */
    get status() {
        return this.world.runs.get(this.runId).then((run) => run.status);
    }
    /**
     * The return value of the workflow run.
     * Polls the workflow return value until it is completed.
     */
    get returnValue() {
        return this.pollReturnValue();
    }
    /**
     * The name of the workflow.
     */
    get workflowName() {
        return this.world.runs.get(this.runId).then((run) => run.workflowName);
    }
    /**
     * The timestamp when the workflow run was created.
     */
    get createdAt() {
        return this.world.runs.get(this.runId).then((run) => run.createdAt);
    }
    /**
     * The timestamp when the workflow run started execution.
     * Returns undefined if the workflow has not started yet.
     */
    get startedAt() {
        return this.world.runs.get(this.runId).then((run) => run.startedAt);
    }
    /**
     * The timestamp when the workflow run completed.
     * Returns undefined if the workflow has not completed yet.
     */
    get completedAt() {
        return this.world.runs.get(this.runId).then((run) => run.completedAt);
    }
    /**
     * The readable stream of the workflow run.
     */
    get readable() {
        return this.getReadable();
    }
    /**
     * Retrieves the workflow run's default readable stream, which reads chunks
     * written to the corresponding writable stream {@link getWritable}.
     *
     * @param options - The options for the readable stream.
     * @returns The `ReadableStream` for the workflow run.
     */
    getReadable(options = {}) {
        const { ops = [], global = globalThis, startIndex, namespace } = options;
        const name = getWorkflowRunStreamId(this.runId, namespace);
        return getExternalRevivers(global, ops, this.runId).ReadableStream({
            name,
            startIndex,
        });
    }
    /**
     * Polls the workflow return value every 1 second until it is completed.
     * @internal
     * @returns The workflow return value.
     */
    async pollReturnValue() {
        while (true) {
            try {
                const run = await this.world.runs.get(this.runId);
                if (run.status === 'completed') {
                    return hydrateWorkflowReturnValue(run.output, [], this.runId);
                }
                if (run.status === 'cancelled') {
                    throw new WorkflowRunCancelledError(this.runId);
                }
                if (run.status === 'failed') {
                    throw new WorkflowRunFailedError(this.runId, run.error);
                }
                throw new WorkflowRunNotCompletedError(this.runId, run.status);
            }
            catch (error) {
                if (WorkflowRunNotCompletedError.is(error)) {
                    await new Promise((resolve) => setTimeout(resolve, 1_000));
                    continue;
                }
                throw error;
            }
        }
    }
}
/**
 * Retrieves a `Run` object for a given run ID.
 *
 * @param runId - The workflow run ID obtained from {@link start}.
 * @returns A `Run` object.
 * @throws WorkflowRunNotFoundError if the run ID is not found.
 */
export function getRun(runId) {
    return new Run(runId);
}
/**
 * Function that creates a single route which handles any workflow execution
 * request and routes to the appropriate workflow function.
 *
 * @param workflowCode - The workflow bundle code containing all the workflow
 * functions at the top level.
 * @returns A function that can be used as a Vercel API route.
 */
export function workflowEntrypoint(workflowCode) {
    const handler = getWorldHandlers().createQueueHandler('__wkf_workflow_', async (message_, metadata) => {
        // Check if this is a health check message
        // NOTE: Health check messages are intentionally unauthenticated for monitoring purposes.
        // They only write a simple status response to a stream and do not expose sensitive data.
        // The stream name includes a unique correlationId that must be known by the caller.
        const healthCheck = parseHealthCheckPayload(message_);
        if (healthCheck) {
            await handleHealthCheckMessage(healthCheck, 'workflow');
            return;
        }
        const { runId, traceCarrier: traceContext, requestedAt, } = WorkflowInvokePayloadSchema.parse(message_);
        // Extract the workflow name from the topic name
        const workflowName = metadata.queueName.slice('__wkf_workflow_'.length);
        const spanLinks = await linkToCurrentContext();
        // Invoke user workflow within the propagated trace context
        return await withTraceContext(traceContext, async () => {
            const world = getWorld();
            return trace(`WORKFLOW ${workflowName}`, { links: spanLinks }, async (span) => {
                span?.setAttributes({
                    ...Attribute.WorkflowName(workflowName),
                    ...Attribute.WorkflowOperation('execute'),
                    ...Attribute.QueueName(metadata.queueName),
                    ...Attribute.QueueMessageId(metadata.messageId),
                    ...getQueueOverhead({ requestedAt }),
                });
                // TODO: validate `workflowName` exists before consuming message?
                span?.setAttributes({
                    ...Attribute.WorkflowRunId(runId),
                    ...Attribute.WorkflowTracePropagated(!!traceContext),
                });
                let workflowStartedAt = -1;
                try {
                    let workflowRun = await world.runs.get(runId);
                    if (workflowRun.status === 'pending') {
                        workflowRun = await world.runs.update(runId, {
                            // This sets the `startedAt` timestamp at the database level
                            status: 'running',
                        });
                    }
                    // At this point, the workflow is "running" and `startedAt` should
                    // definitely be set.
                    if (!workflowRun.startedAt) {
                        throw new Error(`Workflow run "${runId}" has no "startedAt" timestamp`);
                    }
                    workflowStartedAt = +workflowRun.startedAt;
                    span?.setAttributes({
                        ...Attribute.WorkflowRunStatus(workflowRun.status),
                        ...Attribute.WorkflowStartedAt(workflowStartedAt),
                    });
                    if (workflowRun.status !== 'running') {
                        // Workflow has already completed or failed, so we can skip it
                        console.warn(`Workflow "${runId}" has status "${workflowRun.status}", skipping`);
                        // TODO: for `cancel`, we actually want to propagate a WorkflowCancelled event
                        // inside the workflow context so the user can gracefully exit. this is SIGTERM
                        // TODO: furthermore, there should be a timeout or a way to force cancel SIGKILL
                        // so that we actually exit here without replaying the workflow at all, in the case
                        // the replaying the workflow is itself failing.
                        return;
                    }
                    // Load all events into memory before running
                    const events = await getAllWorkflowRunEvents(workflowRun.runId);
                    // Check for any elapsed waits and create wait_completed events
                    const now = Date.now();
                    for (const event of events) {
                        if (event.eventType === 'wait_created') {
                            const resumeAt = event.eventData.resumeAt;
                            const hasCompleted = events.some((e) => e.eventType === 'wait_completed' &&
                                e.correlationId === event.correlationId);
                            // If wait has elapsed and hasn't been completed yet
                            if (!hasCompleted && now >= resumeAt.getTime()) {
                                const completedEvent = await world.events.create(runId, {
                                    eventType: 'wait_completed',
                                    correlationId: event.correlationId,
                                });
                                // Add the event to the events array so the workflow can see it
                                events.push(completedEvent);
                            }
                        }
                    }
                    const result = await runWorkflow(workflowCode, workflowRun, events);
                    // Update the workflow run with the result
                    await world.runs.update(runId, {
                        status: 'completed',
                        output: result,
                    });
                    span?.setAttributes({
                        ...Attribute.WorkflowRunStatus('completed'),
                        ...Attribute.WorkflowEventsCount(events.length),
                    });
                }
                catch (err) {
                    if (WorkflowSuspension.is(err)) {
                        const suspensionMessage = buildWorkflowSuspensionMessage(runId, err.stepCount, err.hookCount, err.waitCount);
                        if (suspensionMessage) {
                            runtimeLogger.debug(suspensionMessage);
                        }
                        const result = await handleSuspension({
                            suspension: err,
                            world,
                            runId,
                            workflowName,
                            workflowStartedAt,
                            span,
                        });
                        if (result.timeoutSeconds !== undefined) {
                            return { timeoutSeconds: result.timeoutSeconds };
                        }
                    }
                    else {
                        const errorName = getErrorName(err);
                        const errorMessage = err instanceof Error ? err.message : String(err);
                        let errorStack = getErrorStack(err);
                        // Remap error stack using source maps to show original source locations
                        if (errorStack) {
                            const parsedName = parseWorkflowName(workflowName);
                            const filename = parsedName?.path || workflowName;
                            errorStack = remapErrorStack(errorStack, filename, workflowCode);
                        }
                        console.error(`${errorName} while running "${runId}" workflow:\n\n${errorStack}`);
                        await world.runs.update(runId, {
                            status: 'failed',
                            error: {
                                message: errorMessage,
                                stack: errorStack,
                                // TODO: include error codes when we define them
                            },
                        });
                        span?.setAttributes({
                            ...Attribute.WorkflowRunStatus('failed'),
                            ...Attribute.WorkflowErrorName(errorName),
                            ...Attribute.WorkflowErrorMessage(String(err)),
                        });
                    }
                }
            }); // End withTraceContext
        });
    });
    return withHealthCheck(handler);
}
// this is a no-op placeholder as the client is
// expecting this to be present but we aren't actually using it
export function runStep() { }
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnVudGltZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9ydW50aW1lLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx5QkFBeUIsRUFDekIsc0JBQXNCLEVBQ3RCLDRCQUE0QixHQUM3QixNQUFNLGtCQUFrQixDQUFDO0FBQzFCLE9BQU8sRUFFTCwyQkFBMkIsR0FJNUIsTUFBTSxpQkFBaUIsQ0FBQztBQUN6QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDakQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUM1QyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNwRCxPQUFPLEVBQ0wsdUJBQXVCLEVBQ3ZCLGdCQUFnQixFQUNoQix3QkFBd0IsRUFDeEIsdUJBQXVCLEVBQ3ZCLGVBQWUsR0FDaEIsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QixPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUNuRSxPQUFPLEVBQUUsUUFBUSxFQUFFLGdCQUFnQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFaEUsT0FBTyxFQUNMLG1CQUFtQixFQUNuQiwwQkFBMEIsR0FDM0IsTUFBTSxvQkFBb0IsQ0FBQztBQUM1QixPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDbEQsT0FBTyxLQUFLLFNBQVMsTUFBTSxxQ0FBcUMsQ0FBQztBQUNqRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsS0FBSyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDL0UsT0FBTyxFQUFFLFlBQVksRUFBRSxhQUFhLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDekQsT0FBTyxFQUNMLDhCQUE4QixFQUM5QixzQkFBc0IsR0FDdkIsTUFBTSxXQUFXLENBQUM7QUFDbkIsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUc1QyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDakQsT0FBTyxFQUlMLFdBQVcsR0FDWixNQUFNLHNCQUFzQixDQUFDO0FBQzlCLE9BQU8sRUFDTCxjQUFjLEVBQ2QsVUFBVSxFQUNWLGFBQWEsR0FDZCxNQUFNLDBCQUEwQixDQUFDO0FBQ2xDLE9BQU8sRUFBcUIsS0FBSyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDOUQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQzNELE9BQU8sRUFDTCxXQUFXLEVBQ1gsUUFBUSxFQUNSLGdCQUFnQixFQUNoQixRQUFRLEdBQ1QsTUFBTSxvQkFBb0IsQ0FBQztBQTZCNUI7O0dBRUc7QUFDSCxNQUFNLE9BQU8sR0FBRztJQUNkOztPQUVHO0lBQ0gsS0FBSyxDQUFTO0lBRWQ7OztPQUdHO0lBQ0ssS0FBSyxDQUFRO0lBRXJCLFlBQVksS0FBYTtRQUN2QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsRUFBRSxDQUFDO0lBQzFCLENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxNQUFNO1FBQ1YsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFRDs7T0FFRztJQUNILElBQUksTUFBTTtRQUNSLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsSUFBSSxXQUFXO1FBQ2IsT0FBTyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDaEMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBSSxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFRDs7T0FFRztJQUNILElBQUksU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUN0RSxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsSUFBSSxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3RFLENBQUM7SUFFRDs7O09BR0c7SUFDSCxJQUFJLFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDeEUsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBSSxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDNUIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILFdBQVcsQ0FDVCxVQUF5QyxFQUFFO1FBRTNDLE1BQU0sRUFBRSxHQUFHLEdBQUcsRUFBRSxFQUFFLE1BQU0sR0FBRyxVQUFVLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxHQUFHLE9BQU8sQ0FBQztRQUN6RSxNQUFNLElBQUksR0FBRyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQzNELE9BQU8sbUJBQW1CLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsY0FBYyxDQUFDO1lBQ2pFLElBQUk7WUFDSixVQUFVO1NBQ1gsQ0FBc0IsQ0FBQztJQUMxQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLEtBQUssQ0FBQyxlQUFlO1FBQzNCLE9BQU8sSUFBSSxFQUFFLENBQUM7WUFDWixJQUFJLENBQUM7Z0JBQ0gsTUFBTSxHQUFHLEdBQUcsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUVsRCxJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssV0FBVyxFQUFFLENBQUM7b0JBQy9CLE9BQU8sMEJBQTBCLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUNoRSxDQUFDO2dCQUVELElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxXQUFXLEVBQUUsQ0FBQztvQkFDL0IsTUFBTSxJQUFJLHlCQUF5QixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDbEQsQ0FBQztnQkFFRCxJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssUUFBUSxFQUFFLENBQUM7b0JBQzVCLE1BQU0sSUFBSSxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDMUQsQ0FBQztnQkFFRCxNQUFNLElBQUksNEJBQTRCLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDakUsQ0FBQztZQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7Z0JBQ2YsSUFBSSw0QkFBNEIsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztvQkFDM0MsTUFBTSxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO29CQUMzRCxTQUFTO2dCQUNYLENBQUM7Z0JBQ0QsTUFBTSxLQUFLLENBQUM7WUFDZCxDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7Q0FDRjtBQUVEOzs7Ozs7R0FNRztBQUNILE1BQU0sVUFBVSxNQUFNLENBQVUsS0FBYTtJQUMzQyxPQUFPLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3hCLENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLGtCQUFrQixDQUNoQyxZQUFvQjtJQUVwQixNQUFNLE9BQU8sR0FBRyxnQkFBZ0IsRUFBRSxDQUFDLGtCQUFrQixDQUNuRCxpQkFBaUIsRUFDakIsS0FBSyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsRUFBRTtRQUMzQiwwQ0FBMEM7UUFDMUMseUZBQXlGO1FBQ3pGLHlGQUF5RjtRQUN6RixvRkFBb0Y7UUFDcEYsTUFBTSxXQUFXLEdBQUcsdUJBQXVCLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDdEQsSUFBSSxXQUFXLEVBQUUsQ0FBQztZQUNoQixNQUFNLHdCQUF3QixDQUFDLFdBQVcsRUFBRSxVQUFVLENBQUMsQ0FBQztZQUN4RCxPQUFPO1FBQ1QsQ0FBQztRQUVELE1BQU0sRUFDSixLQUFLLEVBQ0wsWUFBWSxFQUFFLFlBQVksRUFDMUIsV0FBVyxHQUNaLEdBQUcsMkJBQTJCLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2hELGdEQUFnRDtRQUNoRCxNQUFNLFlBQVksR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN4RSxNQUFNLFNBQVMsR0FBRyxNQUFNLG9CQUFvQixFQUFFLENBQUM7UUFFL0MsMkRBQTJEO1FBQzNELE9BQU8sTUFBTSxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDckQsTUFBTSxLQUFLLEdBQUcsUUFBUSxFQUFFLENBQUM7WUFDekIsT0FBTyxLQUFLLENBQ1YsWUFBWSxZQUFZLEVBQUUsRUFDMUIsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLEVBQ3BCLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRTtnQkFDYixJQUFJLEVBQUUsYUFBYSxDQUFDO29CQUNsQixHQUFHLFNBQVMsQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDO29CQUN2QyxHQUFHLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUM7b0JBQ3pDLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDO29CQUMxQyxHQUFHLFNBQVMsQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQztvQkFDL0MsR0FBRyxnQkFBZ0IsQ0FBQyxFQUFFLFdBQVcsRUFBRSxDQUFDO2lCQUNyQyxDQUFDLENBQUM7Z0JBRUgsaUVBQWlFO2dCQUVqRSxJQUFJLEVBQUUsYUFBYSxDQUFDO29CQUNsQixHQUFHLFNBQVMsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDO29CQUNqQyxHQUFHLFNBQVMsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDO2lCQUNyRCxDQUFDLENBQUM7Z0JBRUgsSUFBSSxpQkFBaUIsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDM0IsSUFBSSxDQUFDO29CQUNILElBQUksV0FBVyxHQUFHLE1BQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBRTlDLElBQUksV0FBVyxDQUFDLE1BQU0sS0FBSyxTQUFTLEVBQUUsQ0FBQzt3QkFDckMsV0FBVyxHQUFHLE1BQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFOzRCQUMzQyw0REFBNEQ7NEJBQzVELE1BQU0sRUFBRSxTQUFTO3lCQUNsQixDQUFDLENBQUM7b0JBQ0wsQ0FBQztvQkFFRCxrRUFBa0U7b0JBQ2xFLHFCQUFxQjtvQkFDckIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUUsQ0FBQzt3QkFDM0IsTUFBTSxJQUFJLEtBQUssQ0FDYixpQkFBaUIsS0FBSyxnQ0FBZ0MsQ0FDdkQsQ0FBQztvQkFDSixDQUFDO29CQUNELGlCQUFpQixHQUFHLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQztvQkFFM0MsSUFBSSxFQUFFLGFBQWEsQ0FBQzt3QkFDbEIsR0FBRyxTQUFTLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQzt3QkFDbEQsR0FBRyxTQUFTLENBQUMsaUJBQWlCLENBQUMsaUJBQWlCLENBQUM7cUJBQ2xELENBQUMsQ0FBQztvQkFFSCxJQUFJLFdBQVcsQ0FBQyxNQUFNLEtBQUssU0FBUyxFQUFFLENBQUM7d0JBQ3JDLDhEQUE4RDt3QkFDOUQsT0FBTyxDQUFDLElBQUksQ0FDVixhQUFhLEtBQUssaUJBQWlCLFdBQVcsQ0FBQyxNQUFNLGFBQWEsQ0FDbkUsQ0FBQzt3QkFFRiw4RUFBOEU7d0JBQzlFLCtFQUErRTt3QkFDL0UsZ0ZBQWdGO3dCQUNoRixtRkFBbUY7d0JBQ25GLGdEQUFnRDt3QkFFaEQsT0FBTztvQkFDVCxDQUFDO29CQUVELDZDQUE2QztvQkFDN0MsTUFBTSxNQUFNLEdBQUcsTUFBTSx1QkFBdUIsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBRWhFLCtEQUErRDtvQkFDL0QsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO29CQUN2QixLQUFLLE1BQU0sS0FBSyxJQUFJLE1BQU0sRUFBRSxDQUFDO3dCQUMzQixJQUFJLEtBQUssQ0FBQyxTQUFTLEtBQUssY0FBYyxFQUFFLENBQUM7NEJBQ3ZDLE1BQU0sUUFBUSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsUUFBZ0IsQ0FBQzs0QkFDbEQsTUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FDOUIsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUNKLENBQUMsQ0FBQyxTQUFTLEtBQUssZ0JBQWdCO2dDQUNoQyxDQUFDLENBQUMsYUFBYSxLQUFLLEtBQUssQ0FBQyxhQUFhLENBQzFDLENBQUM7NEJBRUYsb0RBQW9EOzRCQUNwRCxJQUFJLENBQUMsWUFBWSxJQUFJLEdBQUcsSUFBSSxRQUFRLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQztnQ0FDL0MsTUFBTSxjQUFjLEdBQUcsTUFBTSxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUU7b0NBQ3RELFNBQVMsRUFBRSxnQkFBZ0I7b0NBQzNCLGFBQWEsRUFBRSxLQUFLLENBQUMsYUFBYTtpQ0FDbkMsQ0FBQyxDQUFDO2dDQUNILCtEQUErRDtnQ0FDL0QsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQzs0QkFDOUIsQ0FBQzt3QkFDSCxDQUFDO29CQUNILENBQUM7b0JBRUQsTUFBTSxNQUFNLEdBQUcsTUFBTSxXQUFXLENBQzlCLFlBQVksRUFDWixXQUFXLEVBQ1gsTUFBTSxDQUNQLENBQUM7b0JBRUYsMENBQTBDO29CQUMxQyxNQUFNLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRTt3QkFDN0IsTUFBTSxFQUFFLFdBQVc7d0JBQ25CLE1BQU0sRUFBRSxNQUFzQjtxQkFDL0IsQ0FBQyxDQUFDO29CQUVILElBQUksRUFBRSxhQUFhLENBQUM7d0JBQ2xCLEdBQUcsU0FBUyxDQUFDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQzt3QkFDM0MsR0FBRyxTQUFTLENBQUMsbUJBQW1CLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztxQkFDaEQsQ0FBQyxDQUFDO2dCQUNMLENBQUM7Z0JBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztvQkFDYixJQUFJLGtCQUFrQixDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO3dCQUMvQixNQUFNLGlCQUFpQixHQUFHLDhCQUE4QixDQUN0RCxLQUFLLEVBQ0wsR0FBRyxDQUFDLFNBQVMsRUFDYixHQUFHLENBQUMsU0FBUyxFQUNiLEdBQUcsQ0FBQyxTQUFTLENBQ2QsQ0FBQzt3QkFDRixJQUFJLGlCQUFpQixFQUFFLENBQUM7NEJBQ3RCLGFBQWEsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQzt3QkFDekMsQ0FBQzt3QkFFRCxNQUFNLE1BQU0sR0FBRyxNQUFNLGdCQUFnQixDQUFDOzRCQUNwQyxVQUFVLEVBQUUsR0FBRzs0QkFDZixLQUFLOzRCQUNMLEtBQUs7NEJBQ0wsWUFBWTs0QkFDWixpQkFBaUI7NEJBQ2pCLElBQUk7eUJBQ0wsQ0FBQyxDQUFDO3dCQUVILElBQUksTUFBTSxDQUFDLGNBQWMsS0FBSyxTQUFTLEVBQUUsQ0FBQzs0QkFDeEMsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLENBQUMsY0FBYyxFQUFFLENBQUM7d0JBQ25ELENBQUM7b0JBQ0gsQ0FBQzt5QkFBTSxDQUFDO3dCQUNOLE1BQU0sU0FBUyxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQzt3QkFDcEMsTUFBTSxZQUFZLEdBQ2hCLEdBQUcsWUFBWSxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQzt3QkFDbkQsSUFBSSxVQUFVLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO3dCQUVwQyx3RUFBd0U7d0JBQ3hFLElBQUksVUFBVSxFQUFFLENBQUM7NEJBQ2YsTUFBTSxVQUFVLEdBQUcsaUJBQWlCLENBQUMsWUFBWSxDQUFDLENBQUM7NEJBQ25ELE1BQU0sUUFBUSxHQUFHLFVBQVUsRUFBRSxJQUFJLElBQUksWUFBWSxDQUFDOzRCQUNsRCxVQUFVLEdBQUcsZUFBZSxDQUMxQixVQUFVLEVBQ1YsUUFBUSxFQUNSLFlBQVksQ0FDYixDQUFDO3dCQUNKLENBQUM7d0JBRUQsT0FBTyxDQUFDLEtBQUssQ0FDWCxHQUFHLFNBQVMsbUJBQW1CLEtBQUssa0JBQWtCLFVBQVUsRUFBRSxDQUNuRSxDQUFDO3dCQUNGLE1BQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFOzRCQUM3QixNQUFNLEVBQUUsUUFBUTs0QkFDaEIsS0FBSyxFQUFFO2dDQUNMLE9BQU8sRUFBRSxZQUFZO2dDQUNyQixLQUFLLEVBQUUsVUFBVTtnQ0FDakIsZ0RBQWdEOzZCQUNqRDt5QkFDRixDQUFDLENBQUM7d0JBQ0gsSUFBSSxFQUFFLGFBQWEsQ0FBQzs0QkFDbEIsR0FBRyxTQUFTLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDOzRCQUN4QyxHQUFHLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUM7NEJBQ3pDLEdBQUcsU0FBUyxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQzt5QkFDL0MsQ0FBQyxDQUFDO29CQUNMLENBQUM7Z0JBQ0gsQ0FBQztZQUNILENBQUMsQ0FDRixDQUFDLENBQUMsdUJBQXVCO1FBQzVCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUNGLENBQUM7SUFFRixPQUFPLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNsQyxDQUFDO0FBRUQsK0NBQStDO0FBQy9DLCtEQUErRDtBQUMvRCxNQUFNLFVBQVUsT0FBTyxLQUFJLENBQUMifQ==