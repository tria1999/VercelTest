import { type Event, type WorkflowRun, type WorkflowRunStatus } from '@workflow/world';
export type { Event, WorkflowRun };
export { WorkflowSuspension } from './global.js';
export { type HealthCheckEndpoint, type HealthCheckOptions, type HealthCheckResult, healthCheck, } from './runtime/helpers.js';
export { getHookByToken, resumeHook, resumeWebhook, } from './runtime/resume-hook.js';
export { type StartOptions, start } from './runtime/start.js';
export { stepEntrypoint } from './runtime/step-handler.js';
export { createWorld, getWorld, getWorldHandlers, setWorld, } from './runtime/world.js';
/**
 * Options for configuring a workflow's readable stream.
 */
export interface WorkflowReadableStreamOptions {
    /**
     * An optional namespace to distinguish between multiple streams associated
     * with the same workflow run.
     */
    namespace?: string;
    /**
     * The index number of the starting chunk to begin reading the stream from.
     */
    startIndex?: number;
    /**
     * Any asynchronous operations that need to be performed before the execution
     * environment is paused / terminated
     * (i.e. using [`waitUntil()`](https://developer.mozilla.org/docs/Web/API/ExtendableEvent/waitUntil) or similar).
     */
    ops?: Promise<any>[];
    /**
     * The global object to use for hydrating types from the global scope.
     *
     * Defaults to {@link [`globalThis`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/globalThis)}.
     */
    global?: Record<string, any>;
}
/**
 * A handler class for a workflow run.
 */
export declare class Run<TResult> {
    /**
     * The ID of the workflow run.
     */
    runId: string;
    /**
     * The world object.
     * @internal
     */
    private world;
    constructor(runId: string);
    /**
     * Cancels the workflow run.
     */
    cancel(): Promise<void>;
    /**
     * The status of the workflow run.
     */
    get status(): Promise<WorkflowRunStatus>;
    /**
     * The return value of the workflow run.
     * Polls the workflow return value until it is completed.
     */
    get returnValue(): Promise<TResult>;
    /**
     * The name of the workflow.
     */
    get workflowName(): Promise<string>;
    /**
     * The timestamp when the workflow run was created.
     */
    get createdAt(): Promise<Date>;
    /**
     * The timestamp when the workflow run started execution.
     * Returns undefined if the workflow has not started yet.
     */
    get startedAt(): Promise<Date | undefined>;
    /**
     * The timestamp when the workflow run completed.
     * Returns undefined if the workflow has not completed yet.
     */
    get completedAt(): Promise<Date | undefined>;
    /**
     * The readable stream of the workflow run.
     */
    get readable(): ReadableStream;
    /**
     * Retrieves the workflow run's default readable stream, which reads chunks
     * written to the corresponding writable stream {@link getWritable}.
     *
     * @param options - The options for the readable stream.
     * @returns The `ReadableStream` for the workflow run.
     */
    getReadable<R = any>(options?: WorkflowReadableStreamOptions): ReadableStream<R>;
    /**
     * Polls the workflow return value every 1 second until it is completed.
     * @internal
     * @returns The workflow return value.
     */
    private pollReturnValue;
}
/**
 * Retrieves a `Run` object for a given run ID.
 *
 * @param runId - The workflow run ID obtained from {@link start}.
 * @returns A `Run` object.
 * @throws WorkflowRunNotFoundError if the run ID is not found.
 */
export declare function getRun<TResult>(runId: string): Run<TResult>;
/**
 * Function that creates a single route which handles any workflow execution
 * request and routes to the appropriate workflow function.
 *
 * @param workflowCode - The workflow bundle code containing all the workflow
 * functions at the top level.
 * @returns A function that can be used as a Vercel API route.
 */
export declare function workflowEntrypoint(workflowCode: string): (req: Request) => Promise<Response>;
export declare function runStep(): void;
//# sourceMappingURL=runtime.d.ts.map