import type * as api from '@opentelemetry/api';
import type { Span, SpanKind, SpanOptions } from '@opentelemetry/api';
/**
 * Serializes the current trace context into a format that can be passed through queues
 * @returns A record of strings representing the trace context
 */
export declare function serializeTraceCarrier(): Promise<Record<string, string>>;
/**
 * Deserializes trace context and returns a context that can be used to continue the trace
 * @param traceCarrier The serialized trace context
 * @returns OpenTelemetry context with the restored trace
 */
export declare function deserializeTraceCarrier(traceCarrier: Record<string, string>): Promise<api.Context | undefined>;
/**
 * Runs a function within the context of a deserialized trace
 * @param traceCarrier The serialized trace carrier (optional)
 * @param fn The function to run within the trace context
 * @returns The result of the function
 */
export declare function withTraceContext<T>(traceCarrier: Record<string, string> | undefined, fn: () => Promise<T>): Promise<T>;
export declare function trace<T>(spanName: string, ...args: [fn: (span?: Span) => Promise<T>] | [opts: SpanOptions, fn: (span?: Span) => Promise<T>]): Promise<T>;
export declare function getSpanContextForTraceCarrier(carrier: Record<string, string>): Promise<api.SpanContext | undefined>;
export declare function getActiveSpan(): Promise<api.Span | undefined>;
export declare function instrumentObject<T extends object>(prefix: string, o: T): T;
export declare function getSpanKind(field: keyof typeof SpanKind): Promise<api.SpanKind | undefined>;
export declare function withOtel<T>(fn: (otel: typeof api) => T): Promise<Awaited<T> | undefined>;
export declare function linkToCurrentContext(): Promise<[api.Link] | undefined>;
//# sourceMappingURL=telemetry.d.ts.map