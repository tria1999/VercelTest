import { withResolvers } from '@workflow/utils';
/**
 * Polling interval (in ms) for lock release detection.
 *
 * The Web Streams API does not expose an event for "lock released but stream
 * still open"; we can only distinguish that state by periodically attempting
 * to acquire a reader/writer. For that reason we use polling instead of a
 * fully event-driven approach here.
 *
 * 100ms is a compromise between:
 * - Latency: how quickly we notice that the user has released their lock, and
 * - Cost/CPU usage: how often timers fire, especially with many concurrent
 *   streams or in serverless environments where billed time matters.
 *
 * This value should only be changed with care, as decreasing it will
 * increase polling frequency (and thus potential cost), while increasing it
 * will add worst-case delay before the `done` promise resolves after a lock
 * is released.
 */
export const LOCK_POLL_INTERVAL_MS = 100;
export function createFlushableState() {
    return {
        ...withResolvers(),
        pendingOps: 0,
        doneResolved: false,
        streamEnded: false,
    };
}
/**
 * Checks if a WritableStream is unlocked (user released lock) vs closed.
 * When a stream is closed, .locked is false but getWriter() throws.
 * We only want to resolve via polling when the stream is unlocked, not closed.
 * If closed, the pump will handle resolution via the stream ending naturally.
 */
function isWritableUnlockedNotClosed(writable) {
    if (writable.locked)
        return false;
    let writer;
    try {
        // Try to acquire writer - if successful, stream is unlocked (not closed)
        writer = writable.getWriter();
    }
    catch {
        // getWriter() throws if stream is closed/errored - let pump handle it
        return false;
    }
    try {
        writer.releaseLock();
    }
    catch {
        // If releaseLock() throws for any reason, conservatively treat the
        // stream as closed/errored so callers don't assume it's safe to use.
        // The pump will observe the failure via the stream's end state.
        return false;
    }
    return true;
}
/**
 * Checks if a ReadableStream is unlocked (user released lock) vs closed.
 */
function isReadableUnlockedNotClosed(readable) {
    if (readable.locked)
        return false;
    let reader;
    try {
        // Try to acquire reader - if successful, stream is unlocked (not closed)
        reader = readable.getReader();
    }
    catch {
        // getReader() throws if stream is closed/errored - let pump handle it
        return false;
    }
    try {
        reader.releaseLock();
    }
    catch {
        // If releaseLock() throws for any reason, conservatively treat the
        // stream as closed/errored so callers don't assume it's safe to use.
        // The pump will observe the failure via the stream's end state.
        return false;
    }
    return true;
}
/**
 * Polls a WritableStream to check if the user has released their lock.
 * Resolves the done promise when lock is released and no pending ops remain.
 *
 * Note: Only resolves if stream is unlocked but NOT closed. If the user closes
 * the stream, the pump will handle resolution via the stream ending naturally.
 *
 * Protection: If polling is already active on this state, the existing interval
 * is used to avoid creating multiple simultaneous polling operations.
 */
export function pollWritableLock(writable, state) {
    // Prevent multiple simultaneous polling on the same state
    if (state.writablePollingInterval !== undefined) {
        return;
    }
    const intervalId = setInterval(() => {
        // Stop polling if already resolved or stream ended
        if (state.doneResolved || state.streamEnded) {
            clearInterval(intervalId);
            state.writablePollingInterval = undefined;
            return;
        }
        // Check if lock is released (not closed) and no pending ops
        if (isWritableUnlockedNotClosed(writable) && state.pendingOps === 0) {
            state.doneResolved = true;
            state.resolve();
            clearInterval(intervalId);
            state.writablePollingInterval = undefined;
        }
    }, LOCK_POLL_INTERVAL_MS);
    state.writablePollingInterval = intervalId;
}
/**
 * Polls a ReadableStream to check if the user has released their lock.
 * Resolves the done promise when lock is released and no pending ops remain.
 *
 * Note: Only resolves if stream is unlocked but NOT closed. If the user closes
 * the stream, the pump will handle resolution via the stream ending naturally.
 *
 * Protection: If polling is already active on this state, the existing interval
 * is used to avoid creating multiple simultaneous polling operations.
 */
export function pollReadableLock(readable, state) {
    // Prevent multiple simultaneous polling on the same state
    if (state.readablePollingInterval !== undefined) {
        return;
    }
    const intervalId = setInterval(() => {
        // Stop polling if already resolved or stream ended
        if (state.doneResolved || state.streamEnded) {
            clearInterval(intervalId);
            state.readablePollingInterval = undefined;
            return;
        }
        // Check if lock is released (not closed) and no pending ops
        if (isReadableUnlockedNotClosed(readable) && state.pendingOps === 0) {
            state.doneResolved = true;
            state.resolve();
            clearInterval(intervalId);
            state.readablePollingInterval = undefined;
        }
    }, LOCK_POLL_INTERVAL_MS);
    state.readablePollingInterval = intervalId;
}
/**
 * Creates a flushable pipe from a ReadableStream to a WritableStream.
 * Unlike pipeTo(), this resolves when:
 * 1. The source stream completes (close/error), OR
 * 2. The user releases their lock on userStream AND all pending writes are flushed
 *
 * @param source - The readable stream to read from (e.g., transform's readable)
 * @param sink - The writable stream to write to (e.g., server writable)
 * @param state - The flushable state tracker
 * @returns Promise that resolves when stream ends (not when done promise resolves)
 */
export async function flushablePipe(source, sink, state) {
    const reader = source.getReader();
    const writer = sink.getWriter();
    try {
        while (true) {
            // Check if stream has ended
            if (state.streamEnded) {
                return;
            }
            // Read from source - don't count as pending op since we're just waiting for data
            // The important ops are writes to the sink (server)
            const readResult = await reader.read();
            // Check if stream has ended (e.g., due to error in another path) before processing
            if (state.streamEnded) {
                return;
            }
            if (readResult.done) {
                // Source stream completed - close sink and resolve
                state.streamEnded = true;
                await writer.close();
                // Resolve done promise if not already resolved
                if (!state.doneResolved) {
                    state.doneResolved = true;
                    state.resolve();
                }
                return;
            }
            // Count write as a pending op - this is what we need to flush
            state.pendingOps++;
            try {
                await writer.write(readResult.value);
            }
            finally {
                state.pendingOps--;
            }
        }
    }
    catch (err) {
        state.streamEnded = true;
        if (!state.doneResolved) {
            state.doneResolved = true;
            state.reject(err);
        }
        // Propagate error through flushablePipe's own promise as well.
        // Callers that rely on the FlushableStreamState should use `state.promise`,
        // while other callers may depend on this rejection. Some known callers
        // explicitly ignore this rejection (`.catch(() => {})`) and rely solely
        // on `state.reject(err)` for error handling.
        throw err;
    }
    finally {
        reader.releaseLock();
        writer.releaseLock();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmx1c2hhYmxlLXN0cmVhbS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9mbHVzaGFibGUtc3RyZWFtLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBNkIsYUFBYSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFM0U7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBaUJHO0FBQ0gsTUFBTSxDQUFDLE1BQU0scUJBQXFCLEdBQUcsR0FBRyxDQUFDO0FBNkJ6QyxNQUFNLFVBQVUsb0JBQW9CO0lBQ2xDLE9BQU87UUFDTCxHQUFHLGFBQWEsRUFBUTtRQUN4QixVQUFVLEVBQUUsQ0FBQztRQUNiLFlBQVksRUFBRSxLQUFLO1FBQ25CLFdBQVcsRUFBRSxLQUFLO0tBQ25CLENBQUM7QUFDSixDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFTLDJCQUEyQixDQUFDLFFBQXdCO0lBQzNELElBQUksUUFBUSxDQUFDLE1BQU07UUFBRSxPQUFPLEtBQUssQ0FBQztJQUVsQyxJQUFJLE1BQStDLENBQUM7SUFDcEQsSUFBSSxDQUFDO1FBQ0gseUVBQXlFO1FBQ3pFLE1BQU0sR0FBRyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDaEMsQ0FBQztJQUFDLE1BQU0sQ0FBQztRQUNQLHNFQUFzRTtRQUN0RSxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRCxJQUFJLENBQUM7UUFDSCxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDdkIsQ0FBQztJQUFDLE1BQU0sQ0FBQztRQUNQLG1FQUFtRTtRQUNuRSxxRUFBcUU7UUFDckUsZ0VBQWdFO1FBQ2hFLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUywyQkFBMkIsQ0FBQyxRQUF3QjtJQUMzRCxJQUFJLFFBQVEsQ0FBQyxNQUFNO1FBQUUsT0FBTyxLQUFLLENBQUM7SUFFbEMsSUFBSSxNQUErQyxDQUFDO0lB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