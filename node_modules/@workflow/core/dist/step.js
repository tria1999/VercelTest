import { FatalError, WorkflowRuntimeError } from '@workflow/errors';
import { withResolvers } from '@workflow/utils';
import { EventConsumerResult } from './events-consumer.js';
import { WorkflowSuspension } from './global.js';
import { stepLogger } from './logger.js';
import { hydrateStepReturnValue } from './serialization.js';
export function createUseStep(ctx) {
    return function useStep(stepName, closureVarsFn) {
        // Use a regular function (not arrow) so we can capture `this` when invoked as a method
        const stepFunction = function (...args) {
            const { promise, resolve, reject } = withResolvers();
            const correlationId = `step_${ctx.generateUlid()}`;
            const queueItem = {
                type: 'step',
                correlationId,
                stepName,
                args,
            };
            // Capture `this` value for method invocations (e.g., MyClass.method())
            // Only include if `this` is defined and not the global object
            if (this !== undefined && this !== null && this !== globalThis) {
                queueItem.thisVal = this;
            }
            // Invoke the closure variables function to get the closure scope
            const closureVars = closureVarsFn?.();
            if (closureVars) {
                queueItem.closureVars = closureVars;
            }
            ctx.invocationsQueue.set(correlationId, queueItem);
            // Track whether we've already seen a "step_started" event for this step.
            // This is important because after a retryable failure, the step moves back to
            // "pending" status which causes another "step_started" event to be emitted.
            let hasSeenStepStarted = false;
            stepLogger.debug('Step consumer setup', {
                correlationId,
                stepName,
                args,
            });
            ctx.eventsConsumer.subscribe((event) => {
                if (!event) {
                    // We've reached the end of the events, so this step has either not been run or is currently running.
                    // Crucially, if we got here, then this step Promise does
                    // not resolve so that the user workflow code does not proceed any further.
                    // Notify the workflow handler that this step has not been run / has not completed yet.
                    setTimeout(() => {
                        ctx.onWorkflowError(new WorkflowSuspension(ctx.invocationsQueue, ctx.globalThis));
                    }, 0);
                    return EventConsumerResult.NotConsumed;
                }
                stepLogger.debug('Step consumer event processing', {
                    correlationId,
                    stepName,
                    args: args.join(', '),
                    incomingCorrelationId: event.correlationId,
                    isMatch: correlationId === event.correlationId,
                    eventType: event.eventType,
                });
                if (event.correlationId !== correlationId) {
                    // We're not interested in this event - the correlationId belongs to a different step
                    return EventConsumerResult.NotConsumed;
                }
                if (event.eventType === 'step_started') {
                    // Step has started - so remove from the invocations queue (only on the first "step_started" event)
                    if (!hasSeenStepStarted) {
                        // O(1) lookup and delete using Map
                        if (ctx.invocationsQueue.has(correlationId)) {
                            ctx.invocationsQueue.delete(correlationId);
                        }
                        else {
                            setTimeout(() => {
                                reject(new WorkflowRuntimeError(`Corrupted event log: step ${correlationId} (${stepName}) started but not found in invocation queue`));
                            }, 0);
                            return EventConsumerResult.Finished;
                        }
                        hasSeenStepStarted = true;
                    }
                    // If this is a subsequent "step_started" event (after a retry), we just consume it
                    // without trying to remove from the queue again or logging a warning
                    return EventConsumerResult.Consumed;
                }
                if (event.eventType === 'step_failed') {
                    // Step failed - bubble up to workflow
                    if (event.eventData.fatal) {
                        setTimeout(() => {
                            const error = new FatalError(event.eventData.error);
                            // Preserve the original stack trace from the step execution
                            // This ensures that deeply nested errors show the full call chain
                            if (event.eventData.stack) {
                                error.stack = event.eventData.stack;
                            }
                            reject(error);
                        }, 0);
                        return EventConsumerResult.Finished;
                    }
                    else {
                        // This is a retryable error, so nothing to do here,
                        // but we will consume the event
                        return EventConsumerResult.Consumed;
                    }
                }
                else if (event.eventType === 'step_completed') {
                    // Step has already completed, so resolve the Promise with the cached result
                    const hydratedResult = hydrateStepReturnValue(event.eventData.result, ctx.globalThis);
                    setTimeout(() => {
                        resolve(hydratedResult);
                    }, 0);
                    return EventConsumerResult.Finished;
                }
                else {
                    // An unexpected event type has been received, but it does belong to this step (matching `correlationId`)
                    setTimeout(() => {
                        reject(new WorkflowRuntimeError(`Unexpected event type: "${event.eventType}"`));
                    }, 0);
                    return EventConsumerResult.Finished;
                }
            });
            return promise;
        };
        // Ensure the "name" property matches the original step function name
        // Extract function name from stepName (format: "step//filepath//functionName")
        const functionName = stepName.split('//').pop();
        Object.defineProperty(stepFunction, 'name', {
            value: functionName,
        });
        // Add the step function identifier to the step function for serialization
        Object.defineProperty(stepFunction, 'stepId', {
            value: stepName,
            writable: false,
            enumerable: false,
            configurable: false,
        });
        // Store the closure variables function for serialization
        if (closureVarsFn) {
            Object.defineProperty(stepFunction, '__closureVarsFn', {
                value: closureVarsFn,
                writable: false,
                enumerable: false,
                configurable: false,
            });
        }
        return stepFunction;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9zdGVwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNwRSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDaEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDM0QsT0FBTyxFQUFnQyxrQkFBa0IsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUMvRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBR3pDLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRTVELE1BQU0sVUFBVSxhQUFhLENBQUMsR0FBZ0M7SUFDNUQsT0FBTyxTQUFTLE9BQU8sQ0FDckIsUUFBZ0IsRUFDaEIsYUFBa0Q7UUFFbEQsdUZBQXVGO1FBQ3ZGLE1BQU0sWUFBWSxHQUFHLFVBRW5CLEdBQUcsSUFBVTtZQUViLE1BQU0sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLGFBQWEsRUFBVSxDQUFDO1lBRTdELE1BQU0sYUFBYSxHQUFHLFFBQVEsR0FBRyxDQUFDLFlBQVksRUFBRSxFQUFFLENBQUM7WUFFbkQsTUFBTSxTQUFTLEdBQTRCO2dCQUN6QyxJQUFJLEVBQUUsTUFBTTtnQkFDWixhQUFhO2dCQUNiLFFBQVE7Z0JBQ1IsSUFBSTthQUNMLENBQUM7WUFFRix1RUFBdUU7WUFDdkUsOERBQThEO1lBQzlELElBQUksSUFBSSxLQUFLLFNBQVMsSUFBSSxJQUFJLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSyxVQUFVLEVBQUUsQ0FBQztnQkFDL0QsU0FBUyxDQUFDLE9BQU8sR0FBRyxJQUFvQixDQUFDO1lBQzNDLENBQUM7WUFFRCxpRUFBaUU7WUFDakUsTUFBTSxXQUFXLEdBQUcsYUFBYSxFQUFFLEVB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