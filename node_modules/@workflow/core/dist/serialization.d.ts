import { unflatten } from 'devalue';
/**
 * Detect if a readable stream is a byte stream.
 *
 * @param stream
 * @returns `"bytes"` if the stream is a byte stream, `undefined` otherwise
 */
export declare function getStreamType(stream: ReadableStream): 'bytes' | undefined;
export declare function getSerializeStream(reducers: Reducers): TransformStream<any, Uint8Array>;
export declare function getDeserializeStream(revivers: Revivers): TransformStream<Uint8Array, any>;
export declare class WorkflowServerReadableStream extends ReadableStream<Uint8Array> {
    #private;
    constructor(name: string, startIndex?: number);
}
export declare class WorkflowServerWritableStream extends WritableStream<Uint8Array> {
    constructor(name: string, runId: string | Promise<string>);
}
export interface SerializableSpecial {
    ArrayBuffer: string;
    BigInt: string;
    BigInt64Array: string;
    BigUint64Array: string;
    Date: string;
    Float32Array: string;
    Float64Array: string;
    Error: Record<string, any>;
    Headers: [string, string][];
    Int8Array: string;
    Int16Array: string;
    Int32Array: string;
    Map: [any, any][];
    ReadableStream: {
        name: string;
        type?: 'bytes';
        startIndex?: number;
    } | {
        bodyInit: any;
    };
    RegExp: {
        source: string;
        flags: string;
    };
    Request: {
        method: string;
        url: string;
        headers: Headers;
        body: Request['body'];
        duplex: Request['duplex'];
        responseWritable?: WritableStream<Response>;
    };
    Response: {
        type: Response['type'];
        url: string;
        status: number;
        statusText: string;
        headers: Headers;
        body: Response['body'];
        redirected: boolean;
    };
    Class: {
        classId: string;
    };
    /**
     * Custom serialized class instance.
     * The class must have a `classId` property and be registered for deserialization.
     */
    Instance: {
        classId: string;
        data: unknown;
    };
    Set: any[];
    StepFunction: {
        stepId: string;
        closureVars?: Record<string, any>;
    };
    URL: string;
    URLSearchParams: string;
    Uint8Array: string;
    Uint8ClampedArray: string;
    Uint16Array: string;
    Uint32Array: string;
    WritableStream: {
        name: string;
    };
}
type Reducers = {
    [K in keyof SerializableSpecial]: (value: any) => SerializableSpecial[K] | false;
};
type Revivers = {
    [K in keyof SerializableSpecial]: (value: SerializableSpecial[K]) => any;
};
/**
 * Reducers for serialization boundary from the client side, passing arguments
 * to the workflow handler.
 *
 * @param global
 * @param ops
 * @returns
 */
export declare function getExternalReducers(global: Record<string, any> | undefined, ops: Promise<void>[], runId: string | Promise<string>): Reducers;
/**
 * Reducers for serialization boundary from within the workflow execution
 * environment, passing return value to the client side and into step arguments.
 *
 * @param global
 * @returns
 */
export declare function getWorkflowReducers(global?: Record<string, any>): Reducers;
export declare function getCommonRevivers(global?: Record<string, any>): {
    readonly ArrayBuffer: (value: string) => any;
    readonly BigInt: (value: string) => any;
    readonly BigInt64Array: (value: string) => any;
    readonly BigUint64Array: (value: string) => any;
    readonly Date: (value: string) => any;
    readonly Error: (value: Record<string, any>) => any;
    readonly Float32Array: (value: string) => any;
    readonly Float64Array: (value: string) => any;
    readonly Headers: (value: [string, string][]) => any;
    readonly Int8Array: (value: string) => any;
    readonly Int16Array: (value: string) => any;
    readonly Int32Array: (value: string) => any;
    readonly Map: (value: [any, any][]) => any;
    readonly RegExp: (value: {
        source: string;
        flags: string;
    }) => any;
    readonly Class: (value: {
        classId: string;
    }) => Function;
    readonly Instance: (value: {
        classId: string;
        data: unknown;
    }) => any;
    readonly Set: (value: any[]) => any;
    readonly StepFunction: (value: {
        stepId: string;
        closureVars?: Record<string, any>;
    }) => any;
    readonly URL: (value: string) => any;
    readonly URLSearchParams: (value: string) => any;
    readonly Uint8Array: (value: string) => any;
    readonly Uint8ClampedArray: (value: string) => any;
    readonly Uint16Array: (value: string) => any;
    readonly Uint32Array: (value: string) => any;
};
/**
 * Revivers for deserialization boundary from the client side,
 * receiving the return value from the workflow handler.
 *
 * @param global
 * @param ops
 * @param runId
 */
export declare function getExternalRevivers(global: Record<string, any> | undefined, ops: Promise<void>[], runId: string | Promise<string>): Revivers;
/**
 * Revivers for deserialization boundary from within the workflow execution
 * environment, receiving arguments from the client side, and return values
 * from the steps.
 *
 * @param global
 * @returns
 */
export declare function getWorkflowRevivers(global?: Record<string, any>): Revivers;
/**
 * Called from the `start()` function to serialize the workflow arguments
 * into a format that can be saved to the database and then hydrated from
 * within the workflow execution environment.
 *
 * @param value
 * @param global
 * @param runId
 * @returns The dehydrated value, ready to be inserted into the database
 */
export declare function dehydrateWorkflowArguments(value: unknown, ops: Promise<void>[], runId: string | Promise<string>, global?: Record<string, any>): any;
/**
 * Called from workflow execution environment to hydrate the workflow
 * arguments from the database at the start of workflow execution.
 *
 * @param value
 * @param ops
 * @param global
 * @returns The hydrated value
 */
export declare function hydrateWorkflowArguments(value: Parameters<typeof unflatten>[0], global?: Record<string, any>, extraRevivers?: Record<string, (value: any) => any>): any;
/**
 * Called at the end of a completed workflow execution to serialize the
 * return value into a format that can be saved to the database.
 *
 * @param value
 * @param global
 * @returns The dehydrated value, ready to be inserted into the database
 */
export declare function dehydrateWorkflowReturnValue(value: unknown, global?: Record<string, any>): any;
/**
 * Called from the client side (i.e. the execution environment where
 * the workflow run was initiated from) to hydrate the workflow
 * return value of a completed workflow run.
 *
 * @param value
 * @param ops
 * @param global
 * @param extraRevivers
 * @param runId
 * @returns The hydrated return value, ready to be consumed by the client
 */
export declare function hydrateWorkflowReturnValue(value: Parameters<typeof unflatten>[0], ops: Promise<void>[], runId: string | Promise<string>, global?: Record<string, any>, extraRevivers?: Record<string, (value: any) => any>): any;
/**
 * Called from the workflow handler when a step is being created.
 * Dehydrates values from within the workflow execution environment
 * into a format that can be saved to the database.
 *
 * @param value
 * @param global
 * @returns The dehydrated value, ready to be inserted into the database
 */
export declare function dehydrateStepArguments(value: unknown, global: Record<string, any>): any;
/**
 * Called from the step handler to hydrate the arguments of a step
 * from the database at the start of the step execution.
 *
 * @param value
 * @param ops
 * @param global
 * @param extraRevivers
 * @param runId
 * @returns The hydrated value, ready to be consumed by the step user-code function
 */
export declare function hydrateStepArguments(value: Parameters<typeof unflatten>[0], ops: Promise<any>[], runId: string | Promise<string>, global?: Record<string, any>, extraRevivers?: Record<string, (value: any) => any>): any;
/**
 * Called from the step handler when a step has completed.
 * Dehydrates values from within the step execution environment
 * into a format that can be saved to the database.
 *
 * @param value
 * @param ops
 * @param global
 * @param runId
 * @returns The dehydrated value, ready to be inserted into the database
 */
export declare function dehydrateStepReturnValue(value: unknown, ops: Promise<any>[], runId: string | Promise<string>, global?: Record<string, any>): any;
/**
 * Called from the workflow handler when replaying the event log of a `step_completed` event.
 * Hydrates the return value of a step from the database.
 *
 * @param value
 * @param global
 * @param extraRevivers
 * @param runId
 * @returns The hydrated return value of a step, ready to be consumed by the workflow handler
 */
export declare function hydrateStepReturnValue(value: Parameters<typeof unflatten>[0], global?: Record<string, any>, extraRevivers?: Record<string, (value: any) => any>): any;
export {};
//# sourceMappingURL=serialization.d.ts.map